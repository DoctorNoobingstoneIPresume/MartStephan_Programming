# C++11

 *"If you're an experienced C++ programmer and are anything like me, you initially approached C++11 thinking, "Yes, yes, I get it. It's C++, only more so." But as you learned more, you were surprised by the scope of the changes.* ***auto*** *declarations, range-based* ***for*** *loops,* ***lambda expressions****, and* ***rvalue references*** *change the face of C++, to say nothing of the new* ***concurrency*** *features. And then there are the idiomatic changes.* ***0*** *and* ***typedefs*** *are out,* ***nullptr*** *and alias declarations are in.* ***Enums*** *should now be scoped.* ***Smart pointers*** *are now preferable to built-in ones.* ***Moving objects*** *is normally better than copying them. - Effective Modern C++ by Scott Meyers*  

[TOC]

Table of Contents
=================

* [C\+\+11](#c11)
  * [auto](#auto)
  * [decltype](#decltype)
  * [Alternative Funktionssyntax](#alternative-funktionssyntax)
  * [Uniform Initialization](#uniform-initialization)
  * [Initializer Lists](#initializer-lists)
  * [Direkte Datenfeld\-Initialisierung](#direkte-datenfeld-initialisierung)
  * [Delegation Konstruktoren (Delegating constructors)](#delegation-konstruktoren-delegating-constructors)
  * [Vererbung von Konstruktoren (Inheriting constructors)](#vererbung-von-konstruktoren-inheriting-constructors)
  * [nullptr](#nullptr)
  * [scoped enums](#scoped-enums)
  * [Alias Declarations statt typedef](#alias-declarations-statt-typedef)
  * [Bereichsbasierte For\-Schleifen (Range\-based for Loops)](#bereichsbasierte-for-schleifen-range-based-for-loops)
  * [Deleted Funktionen](#deleted-funktionen)
  * [Overriding Functions](#overriding-functions)
  * [const\_iterators](#const_iterators)
  * [noexcept](#noexcept)
  * [Konstante Ausdrücke (constexpr – constant expressions)](#konstante-ausdr%C3%BCcke-constexpr--constant-expressions)
  * [Klassen\-Funktions Erzeugung (Special Member Function Generation)](#klassen-funktions-erzeugung-special-member-function-generation)
  * [Smart Pointers](#smart-pointers)
  * [Move\-Operator](#move-operator)
  * [Rvalue\-Referenzen, Move\-Semantik und Perfect Forwarding](#rvalue-referenzen-move-semantik-und-perfect-forwarding)
  * [Benutzerdefinierte und Built\-inLiterale](#benutzerdefinierte-und-built-inliterale)
  * [Lambda\-Funktionen](#lambda-funktionen)
  * [Closures](#closures)
  * [bind()](#bind)
  * [Variadische Templates (Variadic templates)](#variadische-templates-variadic-templates)
  * [Statische Zusicherungen zur Compile\-Zeit (Static assertions)](#statische-zusicherungen-zur-compile-zeit-static-assertions)
  * [Type traits](#type-traits)
  * [Aliases Templates](#aliases-templates)
  * [Multithreading](#multithreading)
  * [Futures](#futures)
  * [Async](#async)
  * [Attribute](#attribute)
  * [Unicode strings and constants](#unicode-strings-and-constants)
  * [Maps and Sets](#maps-and-sets)
  * [Concurrency](#concurrency)
  * [Bibliothek](#bibliothek)
  * [C\+\+ Boost](#c-boost)
  * [C\+\+11 Style Guide](#c11-style-guide)
  * [C\+\+11 Compiler support](#c11-compiler-support)
  * [Literatur](#literatur)

Created by [gh-md-toc](https://github.com/ekalinin/github-markdown-toc.go)

## auto

With the *auto* keyword you can declare variables without having to enter a complete type. It is mostly useful if the type is hard to know or hard to write. For example following lines of code.

```C++
// Beispiel für auto 
#include <iostream>
#include <vector>
#include <type_traits>

using namespace std;


int myAdd(int first, int second)
{
    return first + second; 
}


int main()
{
    const auto d = 0.0;
    //auto not;        
   	// ---> does not work as C++ is a static typed language; auto has to be
    // resolved during compilation
    
    auto dd = 5 + d; 
    std::cout << "Give " << dd << "Is double " << std::endl;
        
    std::vector<int> vec {7, 5, 16, 18}; 
    for (auto item: vec)
    {
        std::cout << item << " "; 
    }
    
    auto sum = 0;
    for (auto it = vec.cbegin(); it != vec.cend(); it++)
    {
	   sum += *it;
    }
    std::cout << "\nSum " << sum; 
    
    // Funktionszeiger 
    int (*add)(int first, int second) = myAdd;
    std::cout << "\nold-styple function pointer result=" << add(1, 2); 
    
    // replaced by
    auto addbetter = myAdd;
    std::cout << "\nbetter-styple function pointer result=" << addbetter(1, 2); 
        
    return 0;
}
```

Vorteile sind:  

-  	Sie erspart dem Programmierer u.U. viel unnötige Tipparbeit
-  	Sie hilft, komplexe Template-Typen aufzulösen
-  	Der Compiler kann im Gegensatz zum Programmierer nicht falsch liegen

Zu erwähnen ist noch, dass wir immer *auto&* benutzen müssen, um eine Referenz zu erhalten. Während bei Zeigern es nicht explizit nötig ist. 

```c++
#include <iostream>

struct Point
{
public:
   Point(int xp, int yp) { x=xp; y=yp; }
   int x; 
   int y;
};

Point point(5, 5);

Point& getPoint()
{
   return point;
}
   
int main()
{
   // receives a reference to point
   auto& refPoint = getPoint();
   // deduced to Point & refPoint = getPoint();
   
   std::cout << "x = " << refPoint.x << "\n";  
   
   // receives a copy of point
   auto copyPoint = getPoint();
   // deduced to Point copyPoint = Point(getPoint());
   
   std::cout << "x = " << copyPoint.x << "\n";
}

// x = 5
// x = 5
```

##  decltype

Neben auto kann der in C++11 neu eingeführte Operator *decltype* verwendet werden, um den Typ eines Ausdrucks zur Übersetzungszeit zu bestimmen.   

```C++
int a = 42;
char* b;
char c = {42};
struct D {double x;};
const D* d = new D();  

decltype(a) adecl = 42; // type is int
*decltype(b) bdecl = b; // type is char**
decltype(d->x) ddecl = 5.3; // type is double
```

Mit Hilfe von *decltype* ist es nun möglich, den Rückgabewert von Funktions-Templates automatisch bestimmen zu lassen.  

Man vermeidet dadurch die Nachteile bei Promotion Trait Implementierungen (siehe auch das in C++11 eingeführte Konzept *trailing return type*).

## Alternative Funktionssyntax  

 Eine Funktion der Form

```C++
int add(int a, int b)
{
   return a + b;
}
```

lässt sich mit C++11 Syntax auch folgendermaßen schreiben:

```C++
add(int a, int b)->int { return a + b };
```

Diese Syntax (also die Angabe des Rückgabewertes nach der Funktionssignatur) wird als *trailing return type* bezeichnet.  

Beispiel mit Funktions-Template:

```C++
template<class T> T getValue(T val)
{
   return val++;
}

// neue Syntax
template<class T> auto getValue(T val)->decltype(val)
{
   return val;
}
```

Damit kann man jetzt die Nachteile bei *Promotion Trait* Implementierungen umgehen.  

```C++
template<class T1, class T2> auto add(T1 first, T2 second)->decltype(first+second)
{
   return first + second;
}
```

Folgende Vorteile gegenüber Promotion Traits sind zu nennen:  

-  	Die Typkonvertierung wird durch den Compiler automatisch und richtig vollzogen.
-  	Ein generisches Funktions-Template deckt alle Anwendungsfälle ab.  	
-  	Neue Datentypen müssen nicht nachträglich in das Promotion-Regelwerk eingepflegt werden.  

Ein Hinweis zum Schluß: Das Schlüsselwort *auto* in obiger Typdeklaration leitet die neue Syntax ein, um den Rückgabetyp verzögert zu evaluieren (trailing return type), und ist daher nicht mit der automatischen Typableitung *auto* zu verwechseln.  

## Uniform Initialization

In C++11 gibt es nun mehr Möglichkeiten zur Initialisierung von Variablen. Geschweifte Klammern sind  nun für die Initialisierung erlaubt. Siehe auch *Direkte Datenfeld-Initialisierung.*

```C++
unsigned int x1 = 42;   // C++98
unsigned int x2(42);    // C++98

unsigned int x3 = { 42 };  // C++11
unsigned int x4{42};       // C++11
```

Man kann mit geschweiften Klammern auch Klassen während der Instanziierung mit Werten initialisieren.  

```C++
class Foo
{
   float f;  
   string s;  
};  

Foo foo { 4.2, “hallo” };
Foo foo2 { 4.2 };  
Foo foo3 { };  
```

## Initializer Lists

Das *initializer_list* Ojekt stellt eine Liste von Objekten eines angegebenen Typs dar. Diese können dann in Konstruktoren und anderen Kontexten verwendet werden.  

```C++
// C++11 initializer list
#include <iostream>
#include <initializer_list>

int main()
{
   std::initializer_list<int> int_list {5, 6, 7};  
    
   std::cout << "initializer list size " << int_list.size() << std::endl;
    
   for (int i: int_list)
   {
      std::cout << "value " << i << std::endl;	
   }
   
   return 0;
}

// initializer list size 3
// value 5
// value 6
// value 7
```

Die Standard-Bibliothekscontainerklassen verfügen über *initializer_list* Konstruktoren. Dadurch sind auch direkte Datenfeld-Initialisierungen mit diesen Klassen möglich.  

```C++
std::vector<int> vec{ 5, 6, 7};
```

## Direkte Datenfeld-Initialisierung

 You can now initialize data fields of classes directly within their declaration.

```C++
class Klaas
{
   Int32* ptrToInt = 0;
   double db = 1.0;
};

class Arai
{
public:
   Arai() : myData {1, 2, 3, 4, 5} {}
   Arai(bool allZero) : myData { 0 } {}
private:
   int myData[5]; 
};

const float* data = new const float[3] {1.1, 2.2, 3.3};
```

## Delegation Konstruktoren (Delegating constructors)

Neu in C++11. Bekannt von Java und D. In C++11 kann der Initialisierungscode in einem Konstruktor definiert werden, der dann von allen anderen Konstruktoren verwendet wird.  

```C++
class A
{
public:
   A() : A(0) {}
   A(int i) : A(i, 0) {}
   A(int i, int j)
   {
      num1 = i;
      num2 = j;
      average = (num1 + num2) / 2;
   }
private:
   int num1;
   int num2;
   int average;
}; 

A my_a();
```

Im oben gezeigten Beispiel delegiert der Default-Konstruktor A( ) nach A(int i) und der Konstruktor A(int i) wiederum delegiert nach A(int i, int j).   

Achtung: Man kann Memberinitialisierungen nicht in einem Konstruktor durchführen, der an einen anderen Konstruktor delegiert wird.  

```C++
#include <iostream>
#include <cstdlib>

class A
{
public:
   A();
   A(int, int);
   int a; 
   int b;
};

A::A() : a(0), b(0)
{   
}

// Compile-Fehler aufgrund von Member-Initialisierung in einem Konstruktor, 
// der an einen anderen Konstruktor delegiert wird.  

A::A(int a, int b) : A(), a(a), b(b)  
{
} 
```

## Vererbung von Konstruktoren (Inheriting constructors)

In C++11 können jetzt auch Konstruktoren vererbt werden. Es genügt dazu, die Elternklasse mit der *using*-Direktive in der Definition der Kindklasse anzugeben. 

```C++
class Base
{
public:
   Base();
   Base(int i);
   Base(bool b);
}; 

class Derived
{
public:
   using Base::Base;
   Derived(double d); 
};

// Derived(double d) wird aufgerufen
Derived cut1(2.0); 
// Base(bool b) wird aufgerufen
Derived cut2(true);
// Base(int i) wird aufgerufen
Derived cut3(2);		
```

## nullptr

Bisher konnte man Zeiger auf '0' nur mit entweder dem Integer-Wert 0 vergleichen oder man benutzte *NULL*. Beides hat Nachteile. '0' ist für den Compiler ein Integer und kein expliziter Zeiger-Typ. *NULL* wurde oft innerhalb eines globalen Headers definiert. Deshalb ist *NULL* nie eindeutig. In manchen Headern wurde *NULL* als '0' definiert. In anderen Fällen aber auch mit den Bool-Wert *false*.  

Besser macht es jetzt C++11: Es wurde das Schlüsselwort *nullptr* eingeführt. *nullptr* definiert nun eindeutig einen nicht-initialisierten Zeiger.  

```C++
void f(int x);
void f(bool x);
void f(void* x);

f(0); // calls void f(int x);
f(NULL); // might call void f(int x); or void f(bool x);
f(nullptr); // calls void f(void* x);
```

## scoped enums

Neu in C++11 sind sogenannte *scoped enums*. Sie sind den bisherigen enums-Konstrukten vorzuziehen. Wie der Name schon sagt, ist der Gültigkeitsbereich von *scoped enums* eindeutiger und  logischer. Zusätzlich sind *scoped enums* stärker typisiert.  

Ein weiterer Vorteil von *scoped enums* ist, dass explizit ein Datentyp angegeben werden kann. Dadurch werden *scoped enums* auf jeder Platform gleich interpretiert. Zu beachten ist, dass nur integrale Datentypen wie *char*, *int* und ihre vorzeichenlosen Varianten erlaubt sind. *Floating-Point*-Datentypen hingegen nicht. 

```C++
#include <stdio.h>
#include <iostream>

enum ColorUnscoped {Bleu, Vert, Rouge};		
//auto Bleu = false; 			// compile error; Blue already in scope

enum class ColorScoped {Blue, Green, Red};

// fine; auto Blue is deduced to bool Blue;  
auto Blue = false; 			

// fine; access value Color:Blue in scoped enum
ColorScoped favourite = ColorScoped::Blue; 		

int main()
{
   std::cout << "Ma couleur préférée est " << static_cast<int>(favourite) << std::endl;
      
   return 0;
}

//> Ma couleur préférée est 0
```

Darüber hinaus kann der Programmierer den Typ der Aufzähler spezifizieren.  

```C++
/** 
  * scoped enums specifying underlying type
  */ 
#include <stdio.h>
#include <iostream>
#include <type_traits>

enum class CharColor: std::uint8_t  
{
   red = 0x1,
   blue = 0x2, 
   green = 0x3,
   //gruetze = 0xFFFF here the compiler shouldn't compile <out of range>
};

int main()
{  
   bool same_type = std::is_same< std::uint8_t, std::underlying_type_t<CharColor> >::value;
      
   std::cout << std::boolalpha;
   std::cout << "is_same<unsigned char> " << same_type << std::endl;
      
   return 0;
}

//> is_same<unsigned char> true
```

Im obigen Beispiel sieht man auch, wie man den korrekten Type eines *scoped enums* ermitteln kann. Dazu gibt es Type Traits aus der STL: Im obigen Beispiel *std::underlying_type_t*. Achtung: *std::underlying_type_t* ist C++14. Die Umsetzung in C++11 überlasse ich dem Leser. 

## Alias Declarations statt typedef

*typedef* kann jetzt durch eine einfachere Syntax mittels *using* ersetzt werden. Vor allem in Bezug mit Funktionszeigern wird dadurch die Syntax deutlich vereinfacht.  

```C++
#include <iostream>

namespace MyTypes
{
   enum Feedback
   {
      UNKNOWN,
      OK,
      FAILURE
   };
}
// type alias, Result identical to 
// typedef MyTypes::Feedback Result;
using Result = MyTypes::Feedback;

// type alias, func identical to
// typedef int (*func)(int, int);
using func = int (*) (int, int);
int add(int s1, int s2) {return s1+s2;}
   
// Examples for C++11 Alias Declarations
int main()
{  
   Result res = MyTypes::UNKNOWN;
   std::cout << "result " << res << std::endl;
   
   func f = add;
   std::cout << "func " << f(1, 1) << std::endl;
   
   return 0;
}

// result 0
// func 2
```

Es gibt einen entscheidenden Vorteil Alias-Deklarationen anstelle eines *typedef* zu nutzen: Templates. Einige Beispiele von Alias Declarations. 

```C++
// This file show C++11 Alias Declaration examples
#include <iostream>
#include <cstdlib>
#include <vector>
#include <array>

using myint32 = int;  
using matchingService = std::vector<int>;  

// aka using serviceList = std::vector<std::vector<int>>;

using serviceList = std::vector<matchingService>;   
// type alias used to hide a template parameter 
// you can use now e.g. myarray<int>
template<typename T> using myarray = std::array<T, 3>;
using myfuncptr = void (*)(double d);
  
void funcImpl(double d)
{
	if (d>10.0)
	{
		std::cout << "greater " << std::endl;
	}
	else
	{
		std::cout << "smaller " << std::endl;
	}    
}

int main()
{
   std::cout << "Hello, Wandbox!" << std::endl;

   myint32 i = 0;  
   myint32 j = 2;  
	
   std::cout << "vector = " << i+j << std::endl;
	
   matchingService vec;
   vec.push_back(1);
	
   serviceList svc;
   svc.push_back(vec);
	
   myarray<int> arr;
   arr.fill(4);

   std::cout << "array = " << arr.front() << std::endl;

   myfuncptr f = &(funcImpl);
   f(9);
}
```

## Bereichsbasierte For-Schleifen (Range-based for Loops)

With *range-based for loops* iterating over containers will be easier. It’s similar to *foreach* in other languages.  

```C++
// C++11 range-based for loops
#include <vector>
#include <iostream>

// range-based for loops - iterating over a std::vector

int main()
{
   std::vector<int> vecInt(5);

   // so old-style 
   for (int i=1; i<6; i++)
   {
      vecInt.push_back(i);
   }

   // yes, that's it
   for (int &x: vecInt) x *= 2; // read: for each x in vecInt
   for (int x: vecInt) x *= 2;  // read: for each x in vecInt
   
   return 0;
}
```

 It works with all containers implementing *begin()* and *end()* methods.

## Deleted Funktionen

Falls man Quellcode schreibt und man verhindern will, dass spezifische Funktionen aufgerufen und benutzt werden, dann hat man bisher üblicherweise die Funktionen definiert aber nicht deklariert. Diese ‘Nicht-Deklaration’ wird oft bei den automatisch generierten Konstruktor-Methoden verwendet um ein Aufrufen von z.B. dem Copy-Konstruktor zu verhindern. Der Anwender bekam dadurch einen Linker-Fehler. Der Anwender konnte allerdings nicht davon ausgehen, dass diese Funktionen tatsächlich nicht verwendet werden sollten oder der Entwickler sie schlicht und einfacht nicht vergessen hatte zu implementieren. Dafür wurde in C++11 das Schlüsselwort *delete* eingeführt. Vorteile:  

-  	Explizite Kenntlichmachung, dass eine Funktion nicht implementiert werden soll
-  	Der Compiler kann diesen Fehler (Benutzung einer nicht vorhandenen Funktion) erkennen und eine interpretierbare Fehlermeldung spucken (während Linker-Fehlermeldungen oft nur schwer interpretierbar sind)

```C++
class Meins : public Base
{
	public:
		// verhindere Benutzung des Kopier-Operators   
		Meins(const Meins&) = delete;	
		
		// verhindere Benutzung des Zuweisungs-Operator
		Meins& operator=(const Meins&) = delete;  
}
```

## Overriding Functions

Mit dem Schlüsselwort *override* kann man den Programmierer ‘zwingen’, Funktionen einer Basisklasse in der abgeleiteten Klasse zu überschreiben.  

```C++
class Base
{
public:
	virtual void mf1() const;  
	virtual void mf2(int x);
	virtual void mf3() &;  // lvalue-reference qualified member function
	virtual void mf4() &&; // rvalue-reference qualified member function
};

class Derived : public Base
{
public:  
	virtual void mf1();  
	virtual void mf2(unsigned int x);
	virtual void mf3() &&;  
	virtual void mf4() const;  
};  
```

Obiges Beispiel würde tatsächlich kompilieren. Aber keine der Methoden in der Klasse *Base* wird von einer Methode in der Klasse *Derived* überschrieben, da sich die Signaturen immer geringfügig unterscheiden. Vielleicht wollte der Programmierer aber genau das erreichen?

Um solche ‘Nachlässigkeiten’ zu unterbinden, wird in C++11 das Schlüsselwort *override* eingeführt. Die Klasse *Derived* sähe dann so aus.

```C++
class Derived : public Base
{
public:
	virtual void mf1() const override;  
	virtual void mf2(int x) override;
	virtual void mf3() & override;  
	virtual void mf4() && override;  
};
```

## const_iterators

Wie in älteren Sprachstandards schon zu befolgen: Verwende, soweit möglich, *const*. In C++11 gilt dies genauso für Iteratoren: Falls möglich, verwende *const_iterator*. Therefore container member functions cbegin and cend produce const_iterators.  

```C++
std::vector<int> values;  

auto it = std::find(values.cbegin(), values.cend(), 1983);

values.insert(it, 1998);  
```

## noexcept

Mit dem Schlüsselwort *noexcept* kann man dem Compiler mitteilen, dass eine Funktion keine Ausnahmebehandlung aufruft.  

```C++
int f(int x) noexcept; 
```

Funktionen mit noexcept deklariert können vom Compiler intern optimiert werden. Dies trifft z.B. auf die Verwendung des move-Operators zu. Ein moderner Compiler sollte nach der Strategie “move if you can, but copy if you must” verfahren. Falls eine Funktion mit noexcept deklariert ist, kann der Compiler u.U. eine move-Operation der copy-Operation bevorzugen.  

## Konstante Ausdrücke (constexpr – constant expressions)

Vergleiche auch mit dem Schlüsselwort *pure* in D.   

„Eine Funktion ist pur, wenn sie seiteneffektfrei ist und auch keinerlei nichtkonstanten globalen Zustand verwendet. Eine C++ Funktion lässt sich als *constexpr* deklarieren, wenn sie pur ist und nur aus einer Rückgabeanweisung besteht, die selbst eine *constexpr* ist.“ (aus: „C++11 – auch ein Stimmungsbild“, heise Developer) Auch Konstruktoren können pur sein, falls sie einen leeren Rumpf haben.  

*constexpr* bietet dabei die gleichen bzw. ähnliche Vorteile wie das bekannte *const* Schlüsselwort: Compiler und Linker können schon während der Übersetzungszeit optimieren (z.B. Berechnungen durchführen) und dadurch die Ausführungsgeschwindigkeit erhöhen.  

Zusätzlich ist es auch möglich *constexpr* vor einer Variablendefinition zu setzen, um damit dem Compiler mitzuteilen, die Variable schon während der Compilezeit zu berechnen.  

Und der Unterschied zu *const*? *Const-Objekte* müssen nicht zwingend mit Werten initialisiert werden, die zur Compile-Zeit bekannt sind. Siehe Beispiel.  

```C++
// C++11 constexpr
#include <iostream>
#include <array>

int main()
{
   constexpr auto constexprSize = 3; // compile-time constant
   int size; 
   
   std::cout << "constexpression " << constexprSize << std::endl;

   // passt, da arraySize constexpr ist und der Compiler optimieren kann
   std::array<int, constexprSize> data = {1, 2, 3}; 
   
   std::cout << "data0 " << data[0] << std::endl;
   std::cout << "data1 " << data[1] << std::endl;
   std::cout << "data2 " << data[2] << std::endl;
   
   size = 3; 
   // Funzt. arraySize2 ist const-copy von size aber NICHT zur Compile-Zeit bekannt
   const auto arraySize2 = size;
   
   // Funzt nicht mit constexpr
   //constexpr auto arraySize3 = size; FEHLER
   
   std::cout << "constsize " << arraySize2 << std::endl;
   
   return 0;
}

// constexpression 3
// data0 1
// data1 2
// data2 3
// constsize 3
```

Der Ausdruck *constexpr* kann nicht nur bei Objekten angewandt werden. Auch Funktionen können eine *constexpr* verwenden.  

```C++
// C++11 constexpr
#include <iostream>

constexpr int mult(int multiplikator, int multiplikand)
{
   return multiplikator * multiplikand;
}

int main()
{
   // Ergebnis wird zur Compilezeit berechnet, da 
   // 1) mult() constexpr ist und 
   // 2) die Parameter (10,5) konstante Ausdrücke sind
   auto produkt = mult(10, 5);   
   
   std::cout << "produkt (1) " << produkt << '\n';
   
   // Ergebnis wird zur Laufzeit berechnet, da
   // m und n keine konstanten Ausdrücke sind.
   int m = 10; 
   int n = 6;
   produkt = mult(m, n);
      
   std::cout << "produkt (2) " << produkt << '\n';
   
   return 0;
}

// produkt (1) 50
// produkt (2) 60
```

Nochmals zur Erinnerung: Im letzten Beispiel bedeutet *constexpr* nicht einfach, dass ein const-Wert zurückgeliefert wird. Sondern das Produkt kann als *compile-time* Konstante verwendet werden.  

Anmerkung: Multiplikator und Multiplikand dürfen im obigen Beispiel nicht *compile-time* Konstanten sein. Der Standard erlaubt es und das Produkt würde dann während der Laufzeit berechnet werden.  

## Klassen-Funktions Erzeugung (Special Member Function Generation)

Aus dem bisherigen C++98 Standard kannte man folgende Klassen-Methoden, welche der Compiler selbstständig erzeugen konnte: 

-  	Default Konstruktor
-  	Default-Destruktor
-  	Copy-Konstruktor
-  	Copy-Assignment-Konstruktor

Mit C++11 kommen zwei neue Mitglieder hinzu:  

-  	Move-Konstruktor
-  	Move-Assignment-Konstruktor

```C++
class Foo
{
public:
    // forcing a move constructor to be generated by the compiler
	Foo(Foo&& rhs) = default; 	

    // forcing a move assignment operator to be generated
	Foo& operator=(Foo&& rhs) = default; 	
};  
```

Wie bisher auch werden die move-Konstruktoren nur erzeugt, falls sie benötigt werden. Ein move-Konstruktor führt “elementweise move-Operationen” aus. Falls eine move-Operation für ein Element nicht möglich sein sollte, wird die dazugehörige Copy-Operation durchgeführt.  

Mit dem Schlüsselwort default weise ich den Compiler explizit darauf hin, diese (spezielle) Funktionsmethode zu erzeugen.  

## Smart Pointers  

*Smart Pointers* sind Klassen, die sich wie Zeiger verhalten.   

*Smart Pointers* stellen sicher, dass ein allokiertes Objekt zu gegebener Zeit zerstört wird und verhindert dadurch Speicherlöcher.  

*Smart Pointers* haben den Vorteil, dass man sie in Containerklassen speichern kann.  

Im Prinzip können *Smart Pointers* alles, was simple Zeiger auch können. Nur mit weniger Chancen, fehlerhaften Code zu erzeugen. Deshalb: Falls möglich sind Smart Pointers simplen Zeigern vorzuziehen.  

**unique_ptr**

Unique_ptr is used for dynamically created objects. It manages dynamically created objects with simple ownership semantics. It automatically runs the destruction of the contained object when the pointer goes out of scope. Additionally it destroys the contained object if your function exits with an exception. Unique_ptr objects can be stored in containers, work properly when containers are resized or moved, and will be destroyed when the container is destroyed. Further more, as the name says, a unique_ptr is unique. You can’t make copies of the pointer. Only transfering its resource by using the new move semantic (std::move) is allowed. 

```C++
// Erzeuge neuen unique_ptr mit neuem Objekt
auto song = make_unique<Song>(„Michael Jackson“, „Beat It“);

// Benutze unique_ptr
vector<string> titles = { song→title };

// Move unique_ptr
unique_ptr<Song> song2 = std::move(song);
```

Bemerkung: Ein unique_ptr sollte mit der Hilfsfunktion make_unique erstellt werden.  

**shared_ptr**

“The **shared_ptr** class template stores a pointer to a dynamically allocated object, typically with a C++ *new-expression*. The object pointed to is guaranteed to be deleted when the last **shared_ptr** pointing to it is destroyed or reset.” (Taken from boost.org [11]).

The typical application of a shared_ptr is to use a shared resource. Each shared_ptr owns a pointer to its resource and a reference counter. When creating a shared_ptr its reference counter (for the resource) is incremented by 1. If a shared_ptr is deleted its reference counter is decremented by 1. When the reference counter gets 0 the resoucrce gets automatically deleted.  

Man kann einen *shared_ptr* kopieren, als Wert an Funktionsargumente übergeben oder anderen *shared_ptr* Instanzen zuweisen.  

Wie bei unique_ptr schon gezeigt, sollte nach Möglichkeit make_shared zum Erzeugen eines *shared_ptr* verwendet werden.  

```C++
// Verwende jetzt für obiges Beispiel einen shared_ptr  
auto song = make_shared<Song>(„Michael Jackson“, „Beat It“);

// Man kann einen Smart Pointer auch mit nullptr initialisieren
shared_ptr<Song> song2(nullptr);  

// Oder direkt new verwenden
shared_ptr<Song> song3(new Song(„Lady Gaga“, „Just Dance“));

// Benutze copy-constructor
auto song4(song3);
```

**weak_ptr**

Wie der Name schon sagt, kann man weak_ptr verwenden, um einen *schwachen* Verweis auf einen anderen shared_ptr zu geben. Der weak_ptr selbst nimmt nicht an der Referrenzählung teil.  

Man kann (bzw. muss) einen weak_ptr z.B. benutzen, falls zyklische Verweise zwischen zwei shared_ptr Instanzen unvermeidbar sind.  

```C++
// ref count spFoo is 1
auto spFoo = std::make_shared<Foo>();

// ref count spFoo still remains 1
std::weak_ptr<Foo> wpFoo(spFoo);

// ref count spFoo goes to 0 and Foo is destroyed
spFoo = nullptr;

// weak_ptrs kann man auf Ablauf testen
if (wpFoo.expired())
{
    // do something
}
```

**make_unique und make_shared**

Wie oben schon zu sehen: verwende nach Möglichkeit *make_unique* und *make_shared*, um Intelligente Zeiger zu erstellen und bevorzuge es der Möglichkeit Intelligente Zeiger direkt mit *new* zu erzeugen.  

***Achtung:*** make_shared ist Bestandteil von C++11. Aber make_unique kam erst mit C++14.  

```C++
// shared_ptr mit new erzeugt
std::shared_ptr<Foo> spFoo(new Foo);

// shared_ptr mit make_shared erzeugt
auto spFoo = std::make_shared<Foo>();
```

## Move-Operator

**Copy-Semantik**

![img](file:///D:/Users/MStephan/AppData/Local/Temp/lu49729t3zx.tmp/lu49729t409_tmp_a08ded5ee984f960.png) 

  

**Move-Semantik**

![img](file:///D:/Users/MStephan/AppData/Local/Temp/lu49729t3zx.tmp/lu49729t409_tmp_a08ded5ee984f960.png) 

  

Der Move-Operator wird mit '*&&*' angezeigt. Damit wird dem Compiler ermöglicht, teure Kopier-Operationen durch güntigere Move-Operationen zu ersetzen. Damit einher gehen sogenannte ‚*Move-Only*‘ Typen wie z.B. *std::unique_ptr*, *std::future* und *std::thread*.  

Mit dem Move-Operator können u.U. mögliche Kopier-Operationen vermieden werden.  

```C++
class Person
{
public:
	void addName(const std::string& newName) { names.push_back(newName); }
	void addName(std::string&& newName) { names.push_back(std::move(newName)); }
private:
	std::vector<std::string> names;  
};  

// Nachteil: Zwei Methoden für l-values und r-values.

class Person
{
public:
	void addName(std::string newName) { names.push_back(std::move(newName)); }
};  

// Vorteil: Eine Methode. Compiler kopiert l-values aber verwendet den move-Operator für r-values.  

Person p;  

std::string name(„Homer“);

p.addName(name);   // l-value
p.addName(name + „Simpson“);   // r-value
```

 Im ersten Beispiel (‘*Overloading*’) haben wir:  

-  	eine Kopier-Operation für l-values
-  	eine Move-Operation für r-values

 Im zweiten Beispiel (‘*Pass-by-value*’) haben wir:  

-  	eine Kopier-Operation + eine Move-Operation für l-values
-  	zwei Move-Operationen für r-values  	

## Rvalue-Referenzen, Move-Semantik und Perfect Forwarding

**Rvalue-Referenzen**

Die klassische Definition von *Lvalue* und *Rvalue* besagt, dass *Lvalue*-Werte auf der linken Seite und *Rvalue*-Werte auf der rechten Seite einer Zuweisung stehen dürfen. Was nicht ganz korrekt ist. Als Beispiel definiert Grimm [12] einen *Lvalue* als "Ausdruck ..., von dem die Adresse bestimmt werden kann." Damit lässt er sich potentiell zuweisen. Ein *Rvalue* hingegen kann nur gelesen werden.  

```C++
int getFour() { return 4;}

int i = 1; 	// i ist Lvalue; 1 ist Rvalue

int& lvalueRef = i; 	// lvalueRef ist Lvalue Referenz, i ist Lvalue

int rvalue =  getFour();	// rvalue ist Lvalue; getFour() ist Rvalue

// func ist Lvalue; Lambda-Funktion ist Rvalue  
auto func = [ ]{std::out << 2018 << std::endl;}	
```

Eine *Lvalue*-Referenz wird durch ein & hinter dem Datentyp erzeugt. Zwei && hingegen definieren eine *Rvalue*-Referenz.

```C++
MyData myData;

MyData& lvalueRef = myData();	// Lvalue Referenz

MyData&& rvalueRef = myDataRvalue(MyData());   // Rvalue Referenz
```

**Rvalue-Referenzen Member-Funktionen**

Nicht nur Werte und/oder Parameter können eine Rvalue-Referenz bekommen. Auch Funktionen können mit einer Lvalue-Referenz oder eine Rvalue-Referenz deklariert werden. In der Praxis wird man das eher selten sehen. Trotzdem eine kleine Demonstration.

```c++
/// Example for rvalue reference member function
#include <iostream>

class Base
{
public:
   virtual void mf() & { std::cout << "lvalue reference member function" << "\n"; }     /// lvalue reference member function
   virtual void mf() && { std::cout << "rvalue reference member function" << "\n"; }    /// rvalue reference member function
};

int main()
{
   Base cut;
 
   cut.mf();					// cut is lvalue 
   std::move(cut).mf();			// cut now made rvalue through explicit calling of std::move
   /// info: now you made 'cut' a rvalue - any access to 'cut' after std::move is undefined - do not touch 'cut' anymore
   Base().mf();					// Of course Base() is rvalue
    
   std::cout << "This is the end" << std::endl;
}

///> lvalue reference member function
///> rvalue reference member function
///> rvalue reference member function
///> This is the end
```

**Move-Semantik**

Aus [12]: "Bei der Copy-Semantik wird durch einen Aufruf der Form a=b der Inhalt von b nach a kopiert, während bei der Move-Semantik der Inhalt von b nach a transferiert wird.  

Anhand des swap-Algorithmus kann man schön die Move-Semantik zeigen. 

```C++
#include <iostream>
#include <vector>
#include <algorithm>

template <typename T> void swapMove(T& a, T& b)
{
	T tmp(std::move(a));
	a = std::move(b);
	b = std::move(tmp);
}

int main()
{
	std::cout << "Hello, Martin" << std::endl;
	std::vector<int> vec1 = {1, 2, 3};
	std::vector<int> vec2 = {4, 5, 6};
  
	auto print = [](int& n){std::cout << " " << n;};
   
	std::cout << "vec1: ";
	std::for_each(vec1.begin(), vec1.end(), print);
	std::cout << " &vec1 = " << &vec1[0];
	std::cout << std::endl;
  
	std::cout << "vec2: ";
	std::for_each(vec2.begin(), vec2.end(), print);
	std::cout << " &vec2 = " << &vec2[0];
	std::cout << std::endl;
 
	swapMove(vec1, vec2);
  
	std::cout << "vec1: ";
	std::for_each(vec1.begin(), vec1.end(), print);
	std::cout << " &vec1 = " << &vec1[0];
	std::cout << std::endl;
	  
	std::cout << "vec2: ";
	std::for_each(vec2.begin(), vec2.end(), print);
	std::cout << " &vec2 = " << &vec2[0];
	std::cout << std::endl;
}
```

Noch ein Wort zur automatischen Erzeugung von Move-Konstruktor und Move-Zuweisungsoperator durch den Compiler: Sind alle Datenelemente einer Klasse und deren Basisklasse transferierbar (moveable), dann erzeugt diese der Compiler automatisch.  

"Das Implementieren des Move-Konstruktors verhindert das automatische Erzeugen des Copy-Konstruktors und durch das Implementieren des Move-Zuweisungsoperators wird das automatische Erzeugen des Copy-Zuweisungsoperators unterbunden.

Durch die Definition eines Copy-Konstruktors wird die Erzeugung des Move-Konstruktors und des Move-Zuweisungsoperators verhindert." [12]

**Perfect Forwarding**

Aus [12]: "Nimmt eine Funktion ihre Daten als Lvalue bzw. Rvalue an und verwendet sie sie, um eine weitere Funktion genau mit diesen Daten aufzurufen, so dass deren ursprüngliche Lvalue- bzw. Rvalue-Eigenschaften erhalten bleiben, spricht man von Perfect Forwarding."  

## Benutzerdefinierte und Built-inLiterale

Benutzerdefinierte und Built-in Literale erlauben es, Zahlen mit Einheiten zu verknüpfen. Benutzerdefinierte Literale setzen sich aus Built-in-Literalen, einem Unterstrich und einem Suffix zusammen.  

-  10100010_b
-  63_s
- 10345.5_dm
- 123.45_km
- 100_m
- 131094_cm
- 33_cent
- 'c'_lang_
- "Hallo"_i18h

```C++
#include <iostream>
#include <chrono>

using namespace std::literals::chrono_literals;  
   
int main()
{
	std::cout << "Hallo?" << std::endl;
    
	auto schoolHour = 45min;  
	auto shortBreak = 300s;  
	auto longBreak = 0.25h;  
	auto schoolWay = 15min;
	auto homework = 2h;
   
	auto schoolDayInSeconds = 2 * schoolWay + 6 * schoolHour + 4 * shortBreak + longBreak + homework;  

	std::chrono::duration<double, std::ratio<3600>> schoolDayInHours = schoolDayInSeconds;  
 
	std::cout << "School day in seconds: " << schoolDayInSeconds.count() << std::endl;
	std::cout << "School day in hours: " << schoolDayInHours.count() << std::endl;     
}
```

C++11 kennt noch keine Built-in Literale. C++14 kennt bereits Built-in Literale für binäre und komplexe Zahlen, C++-Strings und Zeitwerte.  

## Lambda-Funktionen

Mit *Lambda* wird eine neue Sprachfunktion in C++11 eingeführt, mit deren Hilfe sich kleine Funktionen an Ort und Stelle definieren lassen. Mit *Lambda* Ausdrücken können die Vorteile von Funktionsobjekten und Funktionszeigern auf einfache Art und Weise ausgedrückt werden. Funktionsobjekte benötigen z.B. eine Klassendefinition. Mit *Lambda* Ausdrücken kann eine Klassendefinition entfallen.  

Eine *Lambda*-Funktion besteht auf folgenden vier Komponenten:  

| Komponente | Beschreibung                                                 |
| ---------- | ------------------------------------------------------------ |
| [ ]        | Bindung an die Variablen des lokalen Bereichs<br />[ ] keine Bindung<br />[=] die Werte werden kopiert<br />[&] die Werte werden referenziert |
| ( )        | Argumente des Funktionskörpers (optional)                    |
| ->         | Rückgabewert (optional)                                      |
| { }        | Funktionskörper                                              |

Ein simples Beispiel demonstriert den Verwendunsgzweck.  

```C++
// This file contains Lambda examples
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <vector>

int sumGlobal = 0;

void myFunction(int val)
{
	sumGlobal += val;
}

int main()
{
	std::cout << "Hallo" << std::endl;
 	std::vector<int> vecInt {1,2,3,4,5,6,7,8,9,10};  
	int sum = 0;    

	// summation with function  
	std::for_each(vecInt.begin(), vecInt.end(), myFunction);    
	std::cout << "Sum with Function: " << sumGlobal << std::endl;  
 
	// summation with lambda
	std::for_each(vecInt.begin(), vecInt.end(), [&sum](int val){sum += val;});
	std::cout << "Sum with Lambda: " << sum << std::endl;  
}
```

Simple *Lambdas* mit Funktionsobjekt. 

```c++
#include <iostream>

int main()
{
   // Funtionsobjekte 'addObj' und 'simple'
   auto addObj = [](int a, int b){ return a + b; };
   auto simple = []{};
   
   std::cout << "résultat " << addObj(1, 1) << std::endl;
   
   // possible Lambda - but what the heck?
   simple();
   
   return 0;
}
```

Implizite Bindung mit this bei Verwendung von [=]. Der this-Zeiger steht bei Verwendung von [=] (und nur dann) implizit zur Verfügung. 

```c++
struct Lambda 
{
   auto foo() 
   {
      // Auf 's' kann zugegriffen werden 
      // '[=]' bewirkt eine implizite Bindung von this 
      return [=] { std::cout << this->s << std::endl; }; 
   }

   std::string s;
};
```

**Achtung:** Die implizite Bindung von *this* führt ab C++20 zu einer deprecated-Warnung. 

## Closures

*Closures* sind spezielle Funktionen, die ihren Aufrufkontext konservieren. *Lambda*-Funktionen vereinen in C++11 die Funktionalität von *Closures* (also Funktionen mit "Gedächtnis") mit der Funktionalität zustandsbehafteter Funktionsobjekte.  

```C++
std::string separator=":";
auto sepColon = [separator](int i){std::cout << i << separator;};  

separator="-";
auto sepMinus = [separator](int i){std::cout << i << separator;};  
   
separator=",";
auto sepComma = [separator](int i){std::cout << i << separator;};  
     
std::for_each(vecInt.begin(), vecInt.end(), sepColon);  
std::cout << std::endl;
      
std::for_each(vecInt.begin(), vecInt.end(), sepMinus);  
std::cout << std::endl;
     
std::for_each(vecInt.begin(), vecInt.end(), sepComma);  
std::cout << std::endl;
```

Im folgenden Beispiel wird eine Variable 'counter' von der Lambda-Funktion verändert. Gleichzeitig konserviert die Lambda-Funktion ihren Kontext, so dass am Ende der Counter entsprechend gesetzt ist.  

```C++
int counter = 0;

auto incrementLambda = [&counter](){counter+=1;};  

incrementLambda();
incrementLambda();

std::cout << "counter = " << counter << std::endl;
```

**Lambda mit Rückgabewert**

Ein simples Beispiel für eine Lambda-Funktion mit Rückgabewert.  

```C++
auto lambdaRetval = [](int x, int y)->int
{
	int z;  
	z = x+y;
	return z;
};  

int res = lambdaRetval(2, 4);

std::cout << "result of lambdaRetval: " << res;
std::cout << std::endl; 
```

## bind()

bind( ) ersetzt jetzt die im Standard (STL) enthaltenen *bind1st* und *bind2nd*. Dadurch wird eine einheitliche und deutlich nutzerfreundlichere Syntax erreicht.   

Mit std::bind kann man beispielsweise:  

-  	die Argumente an beliebige Positionen binden
-  	die Reihenfolge der Argumente umstellen
-  	Platzhalter für Argumente einführen
-  	und einiges anderes mehr  	

```C++
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <functional>
 
void myFunction(int val1, int val2, int val3, int val4)
{
	std::cout << val1 << ' ' << val2 << ' ' << val3 << ' ' << val4;  
	std::cout << std::endl;
}

void myFunction1(int val1, int val2)
{
	std::cout << val1 << ' ' << val2;  
	std::cout << std::endl;
}

int main()
{
	std::cout << "Hallo" << std::endl;
 
	int n=7;

    auto fbind = std::bind(myFunction1, std::placeholders::_2, std::placeholders::_1);
	auto fbind1 = std::bind(myFunction, 4, n, std::placeholders::_2, std::placeholders::_1);
     
	// direct call
	myFunction1(2, 1);
   
	// swap arguments
	fbind(1, 2);
  
	// some kind of 'currying'
	fbind1(1, 2);     
}
```

##  Variadische Templates (Variadic templates)

The variadic template facility allows a variable number of arguments like the old ... varargs syntax, but in a type-safe manner. So you can design functions like the C++-printf.  

*Variadische Templates* sind Templates mit einer beliebigen Anzahl von Parametern. Die Syntax wurde aus der bekannten Syntax von z.B. printf übernommen.  

Das Funktions-Template *istWahr* gibt genau dann *true* zurück, wenn alle Argumente *wahr* sind.

```C++
// Example of C++11 variadic template
#include <iostream>
#include <cstdlib>

template<typename... Args> bool istWahr(Args... args)
{
   bool ergebnis = true; 
   const int size = sizeof...(args) + 2;
   int res[size] = {1,args...,2};

   for (int i=1; i<size-1; i++)
   {
      if (res[i] == false)
      {
         ergebnis = false;
      }
   }

   return ergebnis;
}

int main()
{
   std::cout << std::boolalpha;
   std::cout << "istWahr(true) " << istWahr(true) << std::endl;
   std::cout << "istWahr(true, false) " << istWahr(true, false) << std::endl;
}

// >>> istWahr(true) true
// >>> istWahr(true, false) false
```

Noch genialer, falls man mit Rekursion arbeiten kann. Siehe folgenden Code, der eine beliebige Anzahl von Zahlen addiert. 

```c++
// C++11 Variadic Template

// Template specialisation for the last number
template<typename T>
T add(const T& arg)
{
   return arg;
}

// Variadic template taking a variable number of args
template<typename T, typename... ARGS>
T add(const T& arg, const ARGS&... args)
{
   return arg + add(args...);
}

int main()
{
   // add a variable set of numbers
   return add(1, 2u, 3u);
}

/// >>> 6
```

Fortsetzung findet die Geschichte dann mit den *Fold Expressions* in C++17. 

## Statische Zusicherungen zur Compile-Zeit (Static assertions)

Aus [12]: „Eine statische Zusicherung (static_assert) funktioniert wie das klassische assert()-Makro, jedoch zur Übersetzungszeit und nicht zur Laufzeit.“  

Dadurch kann es zum einen keine negativen Auswirkungen auf das Laufzeitverhalten geben. Allerdings kann man damit natürlich keine laufzeitabhängigen Werte evaluieren.

Die Syntax lautet:

*static_assert(Ausdruck, Text);*

```C++
// This file contains static assertion examples
#include <cstdio>
#include <iostream>
  
int main()
{
   std::cout << "Hallo" << std::endl;
  
   // will it work?
   static_assert(sizeof(void*) >= 8, "Wo lebst du? Wir sind hier in der 64-bit Welt");
}
```
In C++11 ist es zwingend nötig, den zweiten Parameter *Text* mit anzugeben. Seit C++17 ist der zweite Parameter optional und es kann die Syntax *static_assert(Ausdruck);* benutzt werden.

## Type traits

*Type Traits* definiert ein Interface, mit dem man Eigenschaften von Typen abfragen und/oder manipulieren kann. All dies (und das ist der Gag dahinter) passiert zur Compile-Zeit mit Hilfe von Templates.  

Die Bibliothek ist ziemlich mächtig und eine komplette Übersicht hier würde den Rahmen sprengen. Ich verweise auf die Seite cppreference [https://en.cppreference.com/w/cpp/header/type_traits]. 

Ein kleines Beispiel in C++11 soll genügen. Wobei jeder weitere Standard neue Funktionen hinzufügt. 

```c++
//Type Traits Beispiel 
#include <iostream>
#include <type_traits>

using namespace std;

template <typename T> void getGenericType()
{
    cout << "is_void<T>::value: " << is_void<T>::value << endl;
    cout << "is_array<T>::value: " << is_array<T>::value << endl;
    cout << "is_pointer<T>::value: " << is_pointer<T>::value << endl;
    cout << "is_null_pointer<T>::value: " << is_null_pointer<T>::value << endl;
    cout << "is_enum<T>::value: " << is_enum<T>::value << endl;
    cout << "is_class<T>::value: " << is_class<T>::value << endl;
    cout << "is_lvalue_reference<T>::value: " << is_lvalue_reference<T>::value << endl;
    cout << "is_rvalue_reference<T>::value: " << is_rvalue_reference<T>::value << endl;
  
    cout << endl;
}

int main()
{
    getGenericType<void>();              
    getGenericType<int []>();
    getGenericType<int*>();
    getGenericType<std::nullptr_t>();
    class A{int a;};
    getGenericType<A>();
    enum E{e= 1,};
    getGenericType<E>();
    getGenericType<int&>();             
    getGenericType<int&&>();            
   
    return 0;
}

// is_void<T>::value: 1
// is_array<T>::value: 0
// is_pointer<T>::value: 0
// is_null_pointer<T>::value: 0
// is_enum<T>::value: 0
// is_class<T>::value: 0
// is_lvalue_reference<T>::value: 0
// is_rvalue_reference<T>::value: 0
// ...
```

Auch die Möglichkeiten zur Typmodifikation sind mächtig. Hier eine Auswahl. 

```c++
// const-volatile modifications:
remove_const;
remove_volatile;
remove_cv;
add_const;
add_volatile;
add_cv;
   
// reference modifications:
remove_reference;
add_lvalue_reference;
add_rvalue_reference;

// sign modifications:
make_signed;
make_unsigned;
```

## Aliases Templates

  

## Multithreading

 *General*  

1.  	Speichermodell

 The memory model used in C++11 guarantees to protect your data from race conditions – if you use locks correctly.

1.  	std::thread
2.  	std::ref

 *Protecting data*  

1.  	std::mutex
2.  	std::recursive_mutex
3.  	std::timed_mutex
4.  	std::recursive_timed_mutex
5.  	std::lock
6.  	std::unique_lock

 *Protecting data during initialization*

1.  	constexpr
2.  	static
3.  	std::call_once
4.  	std::once_flag

 In case your constructor is declared with the new *constexpr* keyword, an object initialized with that constructor is guaranteed to be initialized before any code is run as part of the static initialization phase.  

 A second option is to use a static variable at block scope. Initialization of a block scope static variable happens the first time the function is called. If a second thread should call the function before the initialization is complete, then the second thread has to wait

 A third option is to use *std::call_once* and *std::once_flag*. When *std::call_once* is used in conjunction with *std::once_flag* then the specified function is called exactly once.

 *Waiting for events*

1.  	std::mutex
2.  	std::this_thread::sleep_for
3.  	std::condition_variable
4.  	Lambda

 *Thread local data*

1.  	thread_local

 Declaring a variable with thread_local specifies that such a variable is thread local. Thus each thread has its own copy of that variable, and that copy exists for the whole lifetime of that thread.  

See also [16].  

## Futures

*Future, Promise* und *Delay* sind in manchen Sprachen (die konkurrierendes Programmieren zulassen) verwendete Synchronisationsmechanismen. C++11 führt nun std::future und std::promise ein.  

Das interessante an *future* und *promise ist,* dass sie den Transfer eines Wertes zwischen zwei Tasks erlauben, ohne dazu einen expliziten Lock-Mechanismus zu benutzen. Falls ein Task einen Wert an den Aufrufer zurückgeben will, dann benutzt er dazu ein *promise.* Die C++11 Implementierung macht es dann möglich, dass dieser Wert im dazugehörigen *future* zur Verfügung steht. Der Implementierer muss dafür keine zusätzlichen Synchronisationsmechanismen implementieren oder beachten.   

Beispiele (siehe [2]):  

Falls ein future<X> f definiert wurde, dann können wir mit get() auf das Ergebnis warten:

X v = f.get( );	// falls nötig warte auf den Rückgabewert  

Du kannst auch abfragen, ob das Ergebnis schon vorhanden ist:  

if (f.wait_for(0) )    // der Wert steht zur Verfügung

 {

​    do something;

 }

 else

 {

​    do something else

}

 Falls du via *promise* einen Wert zurück an *future* senden möchtest:

try

{ 

   X res;  

   // führe die Berechnung durch

​    p.set_value(res);

 }

 catch ( … )  

 {

​    p.set_exception(std::current_exception( ));

}

 Woher bekomme ich nun mein *future* und mein *promise?* Der einfachste Weg ist mittels std::async( ), wie weiter unten beschrieben.  

 Man kann dafür auch den Typ **packaged_task** verwenden, der neben dem Erzeugen einer Task auch das Erzeugen und Verknüpfen eines **future** und **promise** übernimmt und die dafür notwendigen Zugriffsfunktionalitäten bereitstellt. Siehe [2] für ein Beispiel.  

## Async

Mit *std::async* kannst du bequem asynchronen Code ausführen. Der Rückgabewert dabei ist ein *future.* Im einfachsten Falle kann das so aussehen:

```c++
int gib_mir_die_Antwort( );  

std::future<int> antwort = std::async(gib_mir_die_Antwort( ) );  

// mach irgendetwas anderes

int res = antwort::get( ); // hole dir die Antwort
```

Wie du siehst ein relativ bequemer Weg eine Berechnung asynchron ausführen zu lassen ohne die Benutzung von Synchronisationsmechanismen.  

## Attribute

| Attribut               | Bedeutung                                                    |
| ---------------------- | ------------------------------------------------------------ |
| [[carries_dependency]] | siehe http://en.cppreference.com/w/cpp/language/attributes   |
| [[noreturn]]           | Zeigt an, dass die Funktion nicht zurückkehrt (z.B. bei std::exit). Kann nur einer Funktionsdeklaration hinzugefügt werden. |

## Unicode strings and constants



## Maps and Sets

unordered_map, unordered_multimap, unordered_set, unordered_multiset

## Concurrency

Es gibt jetzt atomare Ganzzahlen. Verwende es, falls du eine Ganzzahl hast, die gleichzeitig von mehreren Threads inkrementiert/dekrementiert wird. 

## Bibliothek

**std::chrono**

Mit der *std::chrono* Bibliothek wird das Benutzen von Zeiten, Zeiträumen, Zeitpunkten und Datums- und Uhrzeiten deutlich vereinfacht. 

```c++
// C++11 std::chrono
#include <iostream>
#include <chrono>
#include <ctime>

int fibonacci(int n)
{
    if (n < 3) return 1;
    return fibonacci(n-1) + fibonacci(n-2);
}

int main()
{
   // Definiere Start- und Endzeitpunkt
   std::chrono::time_point<std::chrono::system_clock> start;
   std::chrono::time_point<std::chrono::system_clock> end;
   
   // Ermittle jetzt-Zeitpunkt
   start = std::chrono::system_clock::now();
   // Berechne
   int result = fibonacci(42);
   // Ermittle jetzt-Zeitpunkt
   end = std::chrono::system_clock::now();
   
   std::cout << "Ergebnis " << result << std::endl;
   
   // (end - start) ergibt Zeitdauer
   int elapsed_seconds = 										  		  	     std::chrono::duration_cast<std::chrono::seconds>(end-start).count();
   std::time_t end_time = std::chrono::system_clock::to_time_t(end);

   // std::ctime konvertiert übergebene Zeit in eine textuelle Repräsentation
   std::cout << "finished computation at " << 
      std::ctime(&end_time) << "elapsed time: " << elapsed_seconds << "s\n";
      
   return 0;
}

// Ergebnis 267914296
// finished computation at Mon Nov 18 22:10:16 2019
// elapsed time: 2s
```

**std::regex**

Mit der regex-Bibliothek erhält jetzt auch C++ eine mächtige (und komplizierte?) Möglichkeit für reguläre Ausdrücke. Typische Anwendungsfälle für reguläre Ausdrücke sind:

| Operation                                      | Anwendungsfall                                 |
| ---------------------------------------------- | ---------------------------------------------- |
| std::regex_match                               | Entspricht der Text dem Zeichenmuster          |
| std::regex_search                              | Suche ein Zeichenmuster in dem Text            |
| std::regex_replace                             | Ersetze ein Zeichenmuster in dem Text          |
| std::regex_iterator, std::regex_token_iterator | Iteriere über alle Zeichenmuster in einem Text |

**std::tuple**

Endlich gibt es, wie in anderen Sprachen schon lange, ein Tupel. Ein Tupel ist dabei ein eindimensionales Array mit einer beliebigen Anzahl von Werten und (noch wesentlich interessanter für Programmierer) mit der Möglichkeit, verschiedenartige Typen im Tupel zu speichern.

Die Hilfsfunktion *std::make_tuple(...)* macht dabei Verwendung von Variadischen Templates, um eine beliebige Anzahl von Werten angeben zu können.

```c++
/// Example C++11 tuples
#include <iostream>
#include <tuple>

std::tuple<int, bool, std::string> get_sesam(int id)
{
   // create and insert tuple by using std::make_tuple
   if (id==0) return std::make_tuple(0, true, "wieso");
   if (id==1) return std::make_tuple(1, true, "weshalb");
   if (id==2) return std::make_tuple(2, true, "warum");
   throw std::invalid_argument("id");
}

int main()
{
   auto sesam_0 = get_sesam(0);
   // get access to tupel value by using std::get<index>(tupel)
   std::cout << "int " << std::get<0>(sesam_0) << "\n";
   std::cout << "bool " << std::get<1>(sesam_0) << "\n";
   std::cout << "string " << std::get<2>(sesam_0) << "\n";
}

///> int 0
///> bool 1
///> string wieso
```

## C++ Boost  

Viele Boost-Konzepte sind jetzt in der Standardbibliothek vorhanden und damit für Boost-Entwickler redundant. Eine gute Übersicht liefert [1].

| Boost                           | C++ 11                                       | Comment                                                      |
| ------------------------------- | -------------------------------------------- | ------------------------------------------------------------ |
| Boost.Any                       | std::auto                                    | see *auto*                                                   |
| Boost.Array                     | std::array                                   | Container-Klasse für Arrays konstanter Größe                 |
| Boost.Atomic                    | std::atomic                                  | Ausführung atomarer Operationen in einer Multi-Threaded Umgebung |
| Boost.Chrono                    | std::chrono                                  | see *Bibliothek - std::chrono*                               |
| Boost.Concept_Check             | C++ vnext Concepts                           |                                                              |
| Boost.Date_Time                 | std::chrono::                                | see *Bibliothek - std::chrono*                               |
| Boost.Foreach                   | C++ 11 ranged for                            |                                                              |
| Boost.Function                  | std::function                                |                                                              |
| Boost.Functional/Hash           | std::hash<T>                                 |                                                              |
| Boost.Heap                      | std::priority_queue                          |                                                              |
| Boost.Intrusive                 | STL Container move constructor / assignment  |                                                              |
| Boost.Lambda                    | C++ 11 Lambdas                               |                                                              |
| Boost.Random                    | std::default_random_engine                   |                                                              |
| Boost.Ratio 2.0.0               | std::ratio                                   |                                                              |
| Boost.Ref                       | std::ref                                     |                                                              |
| Boost.Move                      | std::move                                    |                                                              |
| Boost.StaticAssert              | std::static_assert                           |                                                              |
| Boost.String Algorithms Library | std::string                                  |                                                              |
| Boost.Typeof                    | decltype                                     |                                                              |
| Boost.Units                     | std::ratio constexpr                         |                                                              |
| Boost.Unordered                 | std::unordered_set / std::unordered_multiset |                                                              |
| Boost.Xpressive                 | std::regex_match                             |                                                              |
| Boost.TypeErasure               | C++ 14 auto lambdas                          |                                                              |



  



  

## C++11 Style Guide

 Im folgenden eine Liste der C++11 Features, die (aus meiner Sicht) verwendet werden sollen, verwendet werden können und nicht verwendet werden sollen.  

| Feature                                 | Vorschlag                                                    |                                               |
| --------------------------------------- | ------------------------------------------------------------ | --------------------------------------------- |
| Delegating und Inheriting constructors  | Sollten benutzt werden. Syntax einfach und klar. Vermeidet 			Code-Duplizierung. | Ja                                            |
| Smart pointers (shared_ptr, unique_ptr) | Vermeide shared_ptr. shared_ptr können kopiert werden, um den 			Besitz des Objektes zu teilen. Ist aber nicht intuitiv und 			schwierig zu überblicken. Nach Möglichkeit sollte der Code, der 			ein Objekt erzeugt, diese Objekt wieder löschen und auch 			alleiniger Besitzer des Objekts sein. Falls andere Komponenten 			dieses Objekt benutzen wollen, ist ein pass-by-reference oder die 			Übergabe eines Zeigers übersichtlicher und zu bevorzugen.  			 			Falls wirklich eine Objektübergabe nötig ist, 			sollte dies unter Benutzung von unique_ptr geschehen. | shared_ptr: nein 			unique_ptr: kann |
| auto                                    | Scott Meyer beachten                                         | Ja, falls nötig                               |
| Uniform Initialization                  |                                                              | Ja                                            |
| nullptr                                 |                                                              | Ja                                            |
| Alias declarations (using)              |                                                              | Ja                                            |

 

  

## C++11 Compiler support

In [2] you will find useful links to various compiler pages and their support for C++11 and its features. Here I provide a list of C++11 features supported by compilers I mainly use and/or which are most popular.  

 

  

 **GCC**

 For a detailed description see [6].  

 To be able to use the C++11 features (if available) you have to set the compile flag –std=c++0x. 

| **Language feature**                         | **Available** |
| -------------------------------------------- | ------------- |
| shared_ptr                                   | 4.4           |
| unique_ptr                                   | 4.4           |
| Auto 			Types                       | 4.4           |
| Multi-declarator auto                        | 4.4           |
| Removal of auto as a storage-class specifier | 4.4           |
| New function declarator syntax               | 4.4           |
| Delegating constructors                      | 4.7           |
| Inheriting constructors                      | ???           |
| Initializer Lists                            | 4.4           |
| Lambda expressions                           | 4.5           |
| constexpr                                    | 4.6           |
| Closures                                     | No            |
| move-Semantik; Rvalue Referenzen             | 4.3           |
| Static assertions                            | 4.3           |
| Range-based for loop                         | 4.6           |
| Variadic Templates                           | 4.4           |
| std::thread                                  | ???           |
| Futures                                      | ???           |

 

  

 

  

 **Microsoft Visual Studio**

 For a detailed description see [7], [8], and [17].

 

  

| **Language feature**                         | **Studio 2010** | **Studio 2012** | **Studio 2013** |
| -------------------------------------------- | --------------- | --------------- | --------------- |
| shared_ptr                                   | Yes             | Yes             | Yes             |
| unique_ptr                                   | Yes             | Yes             | Yes             |
| Auto Types                                   | Yes             | Yes             | Yes             |
| Multi-declarator auto                        | yes             | Yes             | Yes             |
| Removal of auto as a storage-class specifier | yes             | Yes             | Yes             |
| New function declarator syntax               | Yes             | Yes             | Yes             |
| Delegating constructors                      | No              | No              | Yes             |
| Inheriting constructors                      | ???             |                 |                 |
| Initializer Lists                            | No              |                 |                 |
| Lambda expressions                           | Yes             | Yes             | Yes             |
| constexpr                                    | No              |                 |                 |
| Closures                                     | No              |                 |                 |
| Rvalue reference                             | Yes             | Yes             | Yes             |
| Static assertions                            | Yes             | Yes             | Yes             |
| Range-based for loop                         | No              | Yes             | Yes             |
| Variadic Templates                           | No              | No              | Yes             |
| std::thread                                  | No              | Yes             | Yes             |
| Futures                                      | No              | Yes             | Yes             |

 

  

 **CLANG**

 For a detailed description see [9]

| **Language feature**                         | **Available** |
| -------------------------------------------- | ------------- |
| shared_ptr                                   |               |
| unique_ptr                                   |               |
| Auto Types                                   | 2,9           |
| Multi-declarator auto                        | 2.9           |
| Removal of auto as a storage-class specifier | 2.9           |
| New function declarator syntax               | 2.9           |
| Delegating constructors                      | 3.0           |
| Inheriting constructors                      | ???           |
| Initializer Lists                            | 3.1           |
| Lambda expressions                           | 3.1           |
| constexpr                                    | 3.1           |
| Closures                                     | No            |
| Rvalue reference                             | 2.9           |
| Static assertions                            | 2.9           |
| Range-based for loop                         | 3.0           |
| Variadic Templates                           | 2.9           |
| std::thread                                  | ???           |
| Futures                                      | ???           |

 

  

 

  

 For a list of online C++ compiler sites see: <http://isocpp.org/blog/2013/01/online-c-compilers>

 

  

 Options for CLANG and gcc

| Option     | Description            |
| ---------- | ---------------------- |
| -std=c++11 | C++11 compiler support |
| -std=c++1y | C++14 compiler support |

 

  

## Literatur

[1] C++11 - the new ISO C++ standard, <http://www.stroustrup.com/C++11FAQ.html> (abgerufen am 7. Februar 2019)

[2] C++ Boost in a Nutshell, <http://geekswithblogs.net/JoshReuben/archive/2014/11/17/c-boost-in-a-nutshell.aspx> (abgerufen am 4. Februar 2016)

[3] Modern C++, <https://msdn.microsoft.com/de-de/library/hh279654.aspx> (abgerufen am 3. Januar 2017)

[4] Standard Library Header <type_traits>, http://en.cppreference.com/w/cpp/header/type_traits (abgerufen am 29. Mai 2019)

[5] Seven Languages in Seven Weeks, Bruce A. Tate, Pragmatic Programmers

[6] GCC C++ Standards Support <https://gcc.gnu.org/projects/cxx-status.html> (abgerufen am 13. Januar 2017)

[7] What's new in Visual Studio C++ 2010, <http://msdn.microsoft.com/en-us/library/dd465215.aspx>

[8] C++11 Features in VS2010, <http://blogs.msdn.com/b/vcblog/archive/2010/04/06/c-0x-core-language-features-in-vc10-the-table.aspx> (abgerufen am 20. August 2014)

[9] C++11/C++14 Features in VS2013, <http://blogs.msdn.com/b/vcblog/archive/2013/12/02/c-11-14-core-language-features-in-vs-2013-and-the-nov-2013-ctp.aspx> (abgerufen am 20. August 2014)

[10] Clang Unterstützung für C++, <http://clang.llvm.org/cxx_status.html> (abgerufen am 20. August 2014)

[11] C++11/C++14 Compiler Unterstützung, <http://cpprocks.com/c1114-compiler-and-library-shootout/> (abgerufen am 20. August 2014)

[12] C++11, Rainer Grimm, Addison-Wesley

[13] boost shared_ptr, <http://www.boost.org/doc/libs/1_50_0/libs/smart_ptr/shared_ptr.htm>, (abgerufen am 29.Juni 2012)

[14] C++0x Compiler Support, <https://wiki.apache.org/stdcxx/C++0xCompilerSupport> (abgerufen am 16. März 2016)

[15] C++11 – auch ein Stimmungsbild, heise developer

[16] Simpler Multithreading in C++0x, <http://www.devx.com/SpecialReports/Article/38883/0/page/1>

[17] Anthony Williams: An Introduction to Variadic Templates in C++0x,  <http://www.devx.com/cplus/Article/41533>

[18] Visual Studio 2013 Available Now!, <http://blogs.msdn.com/b/vcblog/archive/2013/10/17/visual-studio-2013-available-now.aspx>, (abgerufen am 18. Oktober 2013)

[19] The future of C++, Herb Sutter, <http://channel9.msdn.com/Events/Build/2013/2-306> (abgerufen am 18. Oktober 2013)

[20] C++ Truths Blog, Sumant Tambe, <http://cpptruths.blogspot.de/> (abgerufen am 14. März 2014)  

[21] More C++ Idioms, Wikibook, <http://en.wikibooks.org/wiki/More_C++_Idioms> (abgerufen am 14. März 2014)

[22] google-styleguide, <https://code.google.com/p/google-styleguide/> (abgerufen am 14. Juli 2014)

[23] Rainer Grimm Blog: Modernes C++, <http://www.grimm-jaud.de/index.php/blog> (abgerufen am 19. September 2017)

[24] C++ Core Guidelines, <http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#main> 	(abgerufen am 19. September 2017)

[25] C++ Online-Compiles, <https://arne-mertz.de/2017/05/online-compilers/> (abgerufen am 29. 	September 2017)    

[26] Standard C++: Current Status, https://isocpp.org/std/status/ (abgerufen am 26. Oktober 2017)

[27] Embedded-Programmierung mit C++, Rainer Grimm, iX 10/2016

[28] C++-Optimierungen durch Compile-Zeit-Tricks, Rainer Grimm, iX 12/2016

[29] Ressourcen schonen mit C++-Funktionen, Rainer Grimm, iX 02/2017

[30] Bartek's coding blog, https://www.bfilipek.com/ (abgerufen am 12. März 2019)

[31] C++ Core Guidelines, Bjarne Stroustrup, Herb Sutter, http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#main (abgerufen am 27. Februar 2020)



  

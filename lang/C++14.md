# C++14

[TOC]

Table of Contents
=================

   * [C++14](#c14)
   * [Table of Contents](#table-of-contents)
      * [Variadic Lambdas](#variadic-lambdas)
      * [Generic (Polymorphic) Lambda Expressions](#generic-polymorphic-lambda-expressions)
      * [Variable Templates](#variable-templates)
      * [Compile-time computation](#compile-time-computation)
      * [Füllzeichen](#füllzeichen)
      * [Benutzerdefinierte Literale](#benutzerdefinierte-literale)
      * [Attribute](#attribute)
      * [Literatur](#literatur)

Created by [gh-md-toc](https://github.com/ekalinin/github-markdown-toc)


## Variadic Lambdas

## Generic (Polymorphic) Lambda Expressions

Generische Lambda-Ausdrücke können ab C++14 neben dem Rückgabetype auch den Argumenttyp automatisch ableiten. 

```c++
#include <iostream>

// This example presents usage of Generic Lambda 
// Expressions as seen in WG21 pager N3649
int main()
{  
   // 'Identity' is a lambda that accepts an argument of any type and
   // returns the value of its parameter. 
   auto Identity = [](auto a) { return a; };
   int three = Identity(3);
   char const* hello = Identity("hello");
   
   std::cout << "Integer " << three << " string " << hello << std::endl;
   
   return 0;
}

// Integer 3 string hello
```

## Variable Templates

Document N3651

## Compile-time computation

Using constexpr functions and literal types. Use it with embedded systems.

## Füllzeichen

Füllzeichen *'* zur Verbesserung der Lesbarkeit von Zahlen. Binäre Literale sind jetzt mit *0b* oder *0B* möglich.   

```c++
#include <iostream>

using namespace std;

int main()
{
	// Füllzeichen	   
   int number = 1'000'287; 
   std::cout << "num " << number << "\n"; 
   
   int hex = 0xaffe'effa; 
   std::cout << "hex " << hex << "\n";
   
   int bin = 0B1100'0011; 
   std::cout << "bin " << bin << "\n";
   
}

// num 1000287
// hex -1342246918
// bin 195
```

## Built-In Literale

C++14 kennt bereits Built-in Literale für binäre und komplexe Zahlen, C++-Strings und Zeitwerte.  

**C++ Strings**

String-Literale werden mit nachgestelltem 's' gekennzeichnet und sollten spätestens mit C++14 den C-Strings vorgezogen werden. Wichtig zu wissen: C++ String-Literale sind keine C-String-Literale und können nicht miteinander verglichen werden.

```c++
// C++14 Built-In Literals 

#include <iostream>
#include <string>
#include <utility>

int main()
{
   std::cout << std::endl;
  
   using namespace std::string_literals;

   /// This ia a string literal in C++14 - see postfix s
   std::string hello = "hello"s; 
    
   std::cout << "string literal " << hello << std::endl;
}

/// string literal hello
```

## Attribute

| Attribut                                 | Beschreibung                                                 |
| ---------------------------------------- | ------------------------------------------------------------ |
| [[deprecated]]; [[deprecated("reason")]] | Zeigt an, dass die Benutzung der mit *deprecated* markierten Entität (noch) geduldet wird, aber in Zukunft eben nicht mehr. |

```c++
// This file shows examples for C++14 [[deprecated]]
#include <iostream>

enum Wieso 
{
    A [[deprecated]] = 1,   // deprecated but still useable - usually a compiler would throw a warning here
    B = 42
}; 


int main()
{        
    std::cout << "Hallo Wand" << std::endl;
    
    Wieso deprecated = A; 
    Wieso antwort = B;
          
    std::cout << "Deprecated but still useable " << deprecated << std::endl;
    std::cout << "Antwort " << antwort << std::endl;
    
    return 0;
}

// Hallo Wand
// Deprecated but still useable 1
// Antwort 42
```



## Literatur

[1] C++14 ist fertig: eine Sprachversion zur geplanten Zeit, Rüdiger Berlich, <http://www.heise.de/developer/meldung/C-14-ist-fertig-eine-Sprachversion-zur-geplanten-Zeit-2294380.html>, abgerufen am 20. August 2014

[2] <http://www.heise.de/ix/artikel/2014/05/links/096.shtml>, abgerufen am 20. August 2014

[3] Bartek's coding blog, https://www.bfilipek.com/, abgerufen am 12. März 2019

[4] Paul Fultz Il's Blog, http://pfultz2.com/blog/2014/09/05/pipable-functions/, abgerufen am 15. Oktober 2019

[5] Neuerungen in C++14, Ulrich Breymann, https://www.informatik-aktuell.de/entwicklung/programmiersprachen/neuerungen-in-cpp-14.html, abgerufen am 17. Februar 2020

[6] Ausblick auf den C++14-Standard, Rüdiger Berlich, https://www.heise.de/developer/artikel/Ausblick-auf-den-C-14-Standard-2301631.html, abgerufen am 25. Februar 2020



  

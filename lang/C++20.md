# C++20

[TOC]

## Modules

Module stellen eine Alternative zu Header-Dateien dar. Siehe auch das Modulkonzept in anderen Sprachen, z.B. Python. Die Vorteile liegen auf der Hand:

- Die Trennung von Header- und Quelldateien aufzulösen
- Verzicht auf Präprozessor-Anweisungen
- Abhängigkeiten von include-Anweisungen zu eliminieren
- schnellere Kompilierzeiten

```C++
import std; // import declaration

int main() 
{
	std::cout << "Hello World" << std::endl; 
} 
```

## Coroutines

Coroutinen unterstützen die asynchrone Programmierung. Es handelt sich um Funktionen, die ihre Ausführung anhalten und wieder aufnehmen können. Dabei behalten sie ihren Zustand. 

C++20 liefert keine konkreten Coroutinen, sondern ein Framework für das Schreiben von Coroutinen. 

```C++
Acceptor accept{443};

while (true)
{
    Socket so = co_await accept.accept();
    auto req = co_await so.read();
    auto resp = handleRequest(req);
    co_await so.write(resp);
}
```

Ein Aufruf wie *auto req = co_await so.read* wartet nicht, bis die Daten verfügbar sind. Stattdessen kommt er sofort zurück und setzt seine Arbeit dann fort, wenn Daten tatsächlich verfügbar sind. 

```c++
Generator<int> getNext(int start = 0, int step = 1)
{
    auto value = start;
    for (int i = 0;; ++i)
    {
        co_yield value;         
        value += step;
    }
}

int main() 
{    
    std::cout << std::endl;
  
    std::cout << "getNext():";
    auto gen = getNext();
    for (int i = 0; i <= 10; ++i) 
    {
        gen.next();             
        std::cout << " " << gen.getValue();                  
    }
   
   std::cout << std::endl;
}
```

Im obigen Beispiel ist *getNext* eine Coroutine. *getNext* besitzt eine Endlosschleife, die den Wert nach *co_yield* zurückgibt. Ein Aufruf *next()* weckt die Coroutine, mit *getValue()* kann danach der Wert abgeholt werden. 

## Concepts

Concepts sind eine Erweiterung der Templates und werden Bestandteil von C++20 sein. Zusätzlich wird eine vereinfachte Syntax eingeführt werden.  

Concepts sind Prädikate zur Compile-Zeit. Sie werden während der Übersetzung evaluiert und liefern einen Wahrheitswert. 

Damit ist es möglich, Anforderungen an die Templates als Teil des Interfaces zu formulieren. Dadurch sollten kryptische Fehlermeldungen des Compilers bei Instanziierung eines Templates mit fehlerhaftem Datentyp Vergangenheit sein. 

In den folgenden Beispielen wird das Concept *Integral* verwendet. 

```c++
template<typename T>
requires Integral<T>()
T ggt(T a, T b)
{
  if (b == 0)
  {
      return a; 
  }
  else
  {
  	return ggt(b, a % b);
  }
}
```

Der Template-Parameter T muß ein *Integral* sein. Man kann das Ganze noch abkürzen. 

```c++
template<Integral T>
T ggt(T a, T b)
{
  if (b == 0)
  { 
      return a; 
  }
  else
  {
  	return ggt(b, a % b);
  }
}
```

Und man kann es tatsächlich nochmals abkürzen. 

```c++
Integral auto ggt(Integral& a, Integral& b)
{
	if (b == 0)
  	{ 
    	return a; 
  	}	
  	else
  	{
  		return ggt(b, a % b);
  	}
}
```

Die Definition des Concept Integral sieht folgendermaßen aus. 

```c++
template<typename T> concept bool Integral()
{
	return std::is_integral<T>::value; 
}
```



## Contracts

## Ranges

Die Bibliothek erlaubt es, wie schon von anderen Sprachen bekannt (z.B. Python), die Algorithmen der Standard Template Library direkt auf Containern auszuführen. Algorithmen lassen sich mit dem Pipe-Symbol ("|") verknüpfen und die Auswertung kann erst bei Nachfrage erfolgen ("lazy evaluation").  

```c++
#include <vector>
#include <ranges>
#include <iostream>
 
int main()
{
	std::vector<int> ints{0, 1, 2, 3, 4, 5};
  	auto even = [](int i){ return 0 == i % 2; };
  	auto square = [](int i) { return i * i; };
 
  	for (int i : ints | std::view::filter(even) |                                     
        std::view::transform(square)) 
   {
   	std::cout << i << ' ';             // 0 4 16
  	}
}
```

Innerhalb der for-Anweisung sieht man die Funktionskomposition mit dem Pipe-Symbol, die man von links nach rechts lesen muss. Wende für jedes Element von *ints* den Filter *even* an und bilde die verbleibenden Argumente auf ihr Quadrat ab. 

## Vergleichsoperator <=> und

## constexpr

## Designated Initializers  

Mit diesem Feature können (unter anderem) Teile eines struct definiert werden. 

```C++
struct A { int x; int y; int z; };

A b {.x = 1, .z = 2};  
```






[1] <https://herbsutter.com/2017/07/15/trip-report-summer-iso-c-standards-meeting-toronto/>

[2] [https://www.heise.de/developer/meldung/Programmiersprachen-Erste-Plaene-fuer-C-20-veroeffentlicht-3772568.htm](https://www.heise.de/developer/meldung/Programmiersprachen-Erste-Plaene-fuer-C-20-veroeffentlicht-3772568.html), abgerufen am 19. November 2018

[3] <https://www.heise.de/developer/meldung/C-20-bekommt-Ranges-und-Erweiterungen-bei-Concepts-4224738.html>, abgerufen am 19. November 2018

[4] <https://herbsutter.com/2018/11/13/trip-report-fall-iso-c-standards-meeting-san-diego/>, abgerufen am 19. November 2018  

[5] https://www.heise.de/developer/meldung/Programmiersprache-Der-Entwurf-von-C-20-ist-abgeschlossen-4317206.html, abgerufen am 25. Februar 2019

[6] Bartek's coding blog, https://www.bfilipek.com/, abgerufen am 12. März 2019

[7] Blog Modernes C++, https://www.heise.de/developer/artikel/Ein-neuer-Thread-mit-C-20-std-jthread-4197595.html, abgerufen am 22. Mai 2019

[8] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Die-vier-grossen-Neuerungen-4568956.html, abgerufen am 05. November 2019

[9] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Ueberblick-zur-Kernsprache-4574153.html, abgerufen am 05. November 2019 



  
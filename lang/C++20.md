# C++20

[TOC]

Table of Contents
=================

* [C\+\+20](#c20)
* [Table of Contents](#table-of-contents)
  * [Modules](#modules)
  * [Coroutines](#coroutines)
  * [Concepts](#concepts)
  * [Ranges](#ranges)
  * [Vergleichsoperator &lt;=&gt; und](#vergleichsoperator--und)
  * [constexpr virtuelle Funktionen](#constexpr-virtuelle-funktionen)
  * [Designated Initializers](#designated-initializers)
  * [String\-Literale als Template\-Parameter](#string-literale-als-template-parameter)
  * [Lambda improvements](#lambda-improvements)
  * [Attribute](#attribute)
  * [consteval und consinit](#consteval-und-consinit)
  * [std::source\_location](#stdsource_location)
  * [Concurrency](#concurrency)
  * [Algorithmen](#algorithmen)
  * [Bibliothek](#bibliothek)
  * [Literatur](#literatur)

Created by [gh-md-toc](https://github.com/ekalinin/github-markdown-toc.go)

## Modules

Module stellen eine Alternative zu Header-Dateien dar. Siehe auch das Modulkonzept in anderen Sprachen, z.B. Python. Die Vorteile liegen auf der Hand:

- Die Trennung von Header- und Quelldateien aufzulösen
- Verzicht auf Präprozessor-Anweisungen
- Abhängigkeiten von include-Anweisungen zu eliminieren
- schnellere Kompilierzeiten

Aktuell verwendet Clang die Endung .cppm für Modulnamen, während cl.exe das Suffix .ixx verwendet. Das folgende Beispiel erstelle ich mit Clang. Mit gcc hatte ich bisher keinen Erfolg mit Modulen. Zuerst die Modul-Datei math.cppm.

```c++
// math.cppm

// this is our module declaration
export module math;

// now implement math functions 

// greatest common divisor
export int gcd(int first, int second)
{
   // using the Euclidean algorithm
   return second == 0 ? first : gcd(second, first % second);
} 

// least common multiple
export int lcm(int first, int second)
{
   int div = gcd(first, second); 
   return div ? (first * (second / div)) : 0;
}
```

Und noch unsere main.cpp.

```C++
// main.cpp
#include "stdio.h"

// Our first C++20 module - of course a math module
import math;

int main()
{   
   // call greatest common divisor from math module
   int res = gcd(2000, 20);
   printf("gcd %d\n", res);
   
   // call least common multiple from math module
   res = lcm(10, 100);
   printf("lcm %d", res);
}
```

Jetzt noch schnell kompilieren, um zu beweisen, dass es auch funktioniert. Ich benutze den Clang 10.0.0 Compiler dafür. 

```pseudocode
>>> clang++.exe -v
>>> clang version 10.0.0
>>> Target: x86_64-pc-windows-msvc
>>> Thread model: posix
>>> InstalledDir: d:\Program Files\LLVM\bin
```

Es geht los. 

```pseudocode
/// Erzeuge aus der Moduledeklaration math.cppm ein vorcompiliertes Modul math.pcm.
>>> clang++.exe -std=c++20 --precompile math.cppm -o math.pcm 

/// Erzeuge eine Übersetzungseinheit math.o, die kein Modul darstellt.
>>> clang++.exe -std=c++20 -c math.pcm -o math.o

/// Erzeuge eine ausführbare Datei math oder math.exe. clang++ benötigt hier noch den Pfad zum Modul.
>>> clang++.exe -std=c++20 -fmodules-ts -fprebuilt-module-path=. math.o main.cpp -o math.exe

/// math.exe ist ausführbar - und die Algorithmen sind korrekt. 
>>> math.exe 
>>> gcd 20
>>> lcm 100
```

## Coroutines

Coroutinen unterstützen die asynchrone Programmierung. Es handelt sich um Funktionen, die ihre Ausführung anhalten und wieder aufnehmen können. Dabei behalten sie ihren Zustand. 

C++20 liefert keine konkreten Coroutinen, sondern ein Framework für das Schreiben von Coroutinen. 

```C++
Acceptor accept{443};

while (true)
{
    Socket so = co_await accept.accept();
    auto req = co_await so.read();
    auto resp = handleRequest(req);
    co_await so.write(resp);
}
```

Ein Aufruf wie *auto req = co_await so.read* wartet nicht, bis die Daten verfügbar sind. Stattdessen kommt er sofort zurück und setzt seine Arbeit dann fort, wenn Daten tatsächlich verfügbar sind. 

```c++
Generator<int> getNext(int start = 0, int step = 1)
{
    auto value = start;
    for (int i = 0;; ++i)
    {
        co_yield value;         
        value += step;
    }
}

int main() 
{    
    std::cout << std::endl;
  
    std::cout << "getNext():";
    auto gen = getNext();
    for (int i = 0; i <= 10; ++i) 
    {
        gen.next();             
        std::cout << " " << gen.getValue();                  
    }
   
   std::cout << std::endl;
}
```

Im obigen Beispiel ist *getNext* eine Coroutine. *getNext* besitzt eine Endlosschleife, die den Wert nach *co_yield* zurückgibt. Ein Aufruf *next()* weckt die Coroutine, mit *getValue()* kann danach der Wert abgeholt werden. 

## Concepts

Concepts sind eine Erweiterung der Templates und werden Bestandteil von C++20 sein. Zusätzlich wird eine vereinfachte Syntax eingeführt werden.  

Concepts sind Prädikate zur Compile-Zeit. Sie werden während der Übersetzung evaluiert und liefern einen Wahrheitswert. 

Damit ist es möglich, Anforderungen an die Templates als Teil des Interfaces zu formulieren. Dadurch sollten kryptische Fehlermeldungen des Compilers bei Instanziierung eines Templates mit fehlerhaftem Datentyp Vergangenheit sein. 

In den folgenden Beispielen wird das Concept *Integral* verwendet. 

```c++
template<typename T>
requires Integral<T>()
T ggt(T a, T b)
{
  if (b == 0)
  {
      return a; 
  }
  else
  {
  	return ggt(b, a % b);
  }
}
```

Der Template-Parameter T muß ein *Integral* sein. Man kann das Ganze noch abkürzen. 

```c++
template<Integral T>
T ggt(T a, T b)
{
  if (b == 0)
  { 
      return a; 
  }
  else
  {
  	return ggt(b, a % b);
  }
}
```

Und man kann es tatsächlich nochmals abkürzen. 

```c++
Integral auto ggt(Integral& a, Integral& b)
{
	if (b == 0)
  	{ 
    	return a; 
  	}	
  	else
  	{
  		return ggt(b, a % b);
  	}
}
```

Die Definition des Concept Integral sieht folgendermaßen aus. 

```c++
template<typename T> concept bool Integral()
{
	return std::is_integral<T>::value; 
}
```

## Ranges

Die Bibliothek erlaubt es, wie schon von anderen Sprachen bekannt (z.B. Python), die Algorithmen der Standard Template Library direkt auf Containern auszuführen. Algorithmen lassen sich mit dem Pipe-Symbol ("|") verknüpfen und die Auswertung kann erst bei Nachfrage erfolgen ("lazy evaluation").  

```c++
#include <vector>
#include <ranges>
#include <iostream>
 
int main()
{
	std::vector<int> ints{0, 1, 2, 3, 4, 5};
  	auto even = [](int i){ return 0 == i % 2; };
  	auto square = [](int i) { return i * i; };
 
  	for (int i : ints | std::view::filter(even) |                                     
        std::view::transform(square)) 
   {
   	std::cout << i << ' ';             // 0 4 16
  	}
}
```

Innerhalb der for-Anweisung sieht man die Funktionskomposition mit dem Pipe-Symbol, die man von links nach rechts lesen muss. Wende für jedes Element von *ints* den Filter *even* an und bilde die verbleibenden Argumente auf ihr Quadrat ab. 

## Vergleichsoperator <=> und

Der Vergleichsoperator <=> bestimmt für zwei Werte A und B, ob A<B, A=B oder A>B ist. Der Compiler kann den Drei-Wege-Vergleichsoperator automatisch erzeugen, indem er mit dem Schlüsselwort *default* darauf hingewiesen wird. 

```c++
// C++20 Spaceship Operator
#include <iostream>
#include <compare>

struct MyInt
{
   int value; 
   MyInt(int v) {value=v;}
   auto operator<=>(const MyInt&) const = default; 
}; 

int main()
{
   MyInt a(4);
   MyInt b(4); 
   
   static_assert(a == b);
   
   return 0;
}
```

## constexpr virtuelle Funktionen

*constexpr* Funktionen durften bisher nicht virtuell sein. Diese Einschränkung fällt mit C++20 weg. 

## Designated Initializers  

Mit diesem Feature können (unter anderem) Teile eines *struct* definiert werden. 

```C++
// C++20 Designated Initializer
#include <iostream>

int main()
{
   struct Point
   {
      int x; 
      int y; 
   };
   
   // C++11 initialisation
   Point point {1, 1};  
   
   std::cout << "Point " << point.x << " " << point.y << std::endl;
   
   // C++20 Designated Initializer
   Point point2 {.x = 2, .y = 2};
   
   std::cout << "Point " << point2.x << " " << point2.y << std::endl;
   
   return 0;
}
```

## String-Literale als Template-Parameter

Man konnte bisher einen String nicht als Template-Parameter einsetzen (außer typisierten Templates). Mit C++20 ist dies nun möglich. 

```c++
template<std::basic_fixed_string T> 
class Foo 
{
	static constexpr char const* Name = T;
public:
	void hello() const;
};

int main() 
{
    Foo<"Hello!"> foo;
    foo.hello();
}

// Hello!
```

## Lambda improvements

Die **implizite Bindung von this** bei Verwendung von [=] ist Geschichte. 

```c++
struct Lambda 
{
   auto foo() 
   {
// warning: implicit capture of 'this' via '[=]' is deprecated in C++20 [-Wdeprecated]
       return [=] { std::cout << s << std::endl; };
// warning: implicit capture of 'this' via '[=]' is deprecated in C++20 [-Wdeprecated]
   }

   std::string s;
};

struct LambdaCpp20 
{
   auto foo() 
   {
      // OK
      return [=, this] { std::cout << s << std::endl; };
   }

   std::string s;
};
```

**Template-Lambdas** 

Manchmal ist es notwendig, eine Lambda-Funktion zu definieren, die nur für bestimmte Datentypen verwendet werden kann. C++20 unterstützt dafür jetzt *Template-Lambdas*. 

```c++
auto foo = []<typename T>(std::vector<T> const& vec) { 
   // do vector specific stuff 
};
```

## Attribute

| Attribut     | Beschreibung                                                 |
| ------------ | ------------------------------------------------------------ |
| [[likely]]   | Codepfad wird mit höherer Wahrscheinlichkeit ausgeführt      |
| [[unlikely]] | Codepfad wird mit höherer Wahrscheinlichkeit nicht ausgeführt |

## consteval und consinit

Mit *consteval* erzeugt man eine sogenannte Immediate-Funktion. Jeder Aufruf erzeugt einen konstanten Ausdruck, der zur Compilezeit ausgewertet werden kann. 

*constinit* gibt die Garantie, dass eine Variable mit statischer Speicherdauer zur Compilezeit initialisiert wird. 

## std::source_location

Die Klasse std::source_location gibt den Dateinamen, die Zeilen- und die Spaltennummer und den Funktionsnamen zurück. Damit kann man auf die allseits beliebten Präprozessor-Makros LINE und FILE verzichten. 

```c++
#include <source_location>

// ....
```

## Concurrency

**std::atomic_ref**

Das Klassen-Template std::atomic_ref bietet atomare Operationen auf das referenzierte, nicht atomare Objekt an. 

```c++

```

**Atomare Shared Pointer und Weak Pointer**

Shared Pointer und Weak Pointer gibt es jetzt auch atomar. 

**Atomare Gleitkommazahlen**

Seit C++11 gibt es schon atomare Ganzzahlen. Mit C++20 bekommen wir atomare Gleitkommazahlen. 

**Semaphoren, Latches und Barriers** 

Mit C++20 bekommen wir eine eingebaute Semaphore-Implementierung. 

Mit Latches und Barriers werden einfache Synchronisationsmechanismen eingeführt. Sie erlauben es, Threads zu blockieren, bis ein Zähler den Wert 0 besitzt. 

```c++

```

**Joining Thread**

Ein Joining Thread (*std::jthread*) 'joint' automatisch und er kann auch unterbrochen werden. Mit std::thread aus C++11 war das bisher nicht möglich. 

```c++

```

## Algorithmen

**std::find, std::find_if, std::find_if_not**

Da habe ich schon lange darauf gewartet. Endlich gibt es Suchfunktionen für die Containerklassen. Das vereinfacht das Leben doch enorm. Zum Beispiel wenn ich mir die Frage nach dem Sinn des Lebens stelle. 

```c++
// C++20 find example
#include <iostream>
#include <vector>

int main()
{
   std::cout << "Hello, Wandbox!" << std::endl;
    
   std::vector<int> myvector {1, 10, 1000, 4, 42, 399};
    
   // Find die Antwort auf den Sinn des Lebens in einer Zeile Code!
   auto result = std::find(myvector.begin(), myvector.end(), 42);
   
   if (result!=std::end(myvector))
   {
      std::cout << "Found the answer\n";
   }
   else 
   {
      std::cout << "Didn't find the answer\n"; 
   }
   std::cout << std::endl;
}

//Found the answer
```

## Bibliothek 

**chrono**

Die chrono-Bibliothek wird um einen Kalender und um Zeitzonen erweitert. Damit ist es nun möglich:

- ein Datum in verschiedenen Formaten zu repräsentieren
- den letzten Tag eines Monats zu bestimmen
- die Anzahl der Tage zwischen zwei Daten zu bestimmen
- die Ausgabe der aktuellen Zeit in verschiedenen Zeitzonen zu bestimmen

**std::span**

*std::span* steht für ein Objekt, das sich auf eine zusammenhängende Sequenz von Objekten bezieht. Der zusammenhängende Bereich kann ein Array, ein Zeiger oder auch ein *std::vector* sein.

```c++
// C++20 std::span
#include <iostream>
#include <span>

template<typename T>
void copyN(T* src, T* dest, int n)
{
   for (int i=0; i<n; i++)
   {
      dest[i] = src[i];
   }
}

template<typename T>
void copySpan(std::span<const T> src, std::span<T> dest)
{
}

int main()
{
   int arr1[] = {1, 2, 3};
   int arr2[] = {3, 4, 5};
  
   copyN(arr1, arr2, 3);
   std::cout << "copyN ";
   for (int i=0; i<3; i++)
   {
      std::cout << " " << arr2[i];
   }
   std::cout << std::endl;
   
   // Usage of std::span. No need to add the array length.
   // This is much more convenient and reduces the risk of a size mismatch.
   //copySpan(arr1, arr2);
   
   return 0;
}

```

**constexpr-Container**

*std::string* und *std::vector* erhalten jetzt Überladungen mit constexpr. Dadurch können Funktionen der Container-Klassen zur Compilezeit verwendet werden. 

Details können hier http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0784r1.html nachgelesen werden. 

**std::format**

Die *std::format* Bibliothek bietet jetzt eine Alternative zur printf-Funktionalität. 


## Literatur

[1] <https://herbsutter.com/2017/07/15/trip-report-summer-iso-c-standards-meeting-toronto/>

[2] [https://www.heise.de/developer/meldung/Programmiersprachen-Erste-Plaene-fuer-C-20-veroeffentlicht-3772568.htm](https://www.heise.de/developer/meldung/Programmiersprachen-Erste-Plaene-fuer-C-20-veroeffentlicht-3772568.html), abgerufen am 19. November 2018

[3] <https://www.heise.de/developer/meldung/C-20-bekommt-Ranges-und-Erweiterungen-bei-Concepts-4224738.html>, abgerufen am 19. November 2018

[4] <https://herbsutter.com/2018/11/13/trip-report-fall-iso-c-standards-meeting-san-diego/>, abgerufen am 19. November 2018  

[5] https://www.heise.de/developer/meldung/Programmiersprache-Der-Entwurf-von-C-20-ist-abgeschlossen-4317206.html, abgerufen am 25. Februar 2019

[6] Bartek's coding blog, https://www.bfilipek.com/, abgerufen am 12. März 2019

[7] Blog Modernes C++, https://www.heise.de/developer/artikel/Ein-neuer-Thread-mit-C-20-std-jthread-4197595.html, abgerufen am 22. Mai 2019

[8] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Die-vier-grossen-Neuerungen-4568956.html, abgerufen am 05. November 2019

[9] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Ueberblick-zur-Kernsprache-4574153.html, abgerufen am 05. November 2019 

[10] Simplify Your Code With Rocket Science: C++20’s Spaceship Operator, https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/, abgerufen am 07. November 2019

[11] Lambdas: From C++11 to C++20, https://www.bfilipek.com/2019/02/lambdas-story-part1.html, abgerufen am 08. November 2019

[12] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Ueberblick-zur-Bibliothek-4582224.html, abgerufen am 18. November 2019

[13] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Ueberblick-zur-Concurrency-4585408.html, abgerufen am 14. Dezember 2019

[14] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Concepts-die-Details-4599997.html, abgerufen am 16. Januar 2020

[15] C++20 is here!, YouTube, https://www.youtube.com/watch?v=AvPiGstxV_g, abgerufen am 19. Februar 2020

[16] Using C++ Modules in Visual Studio 2017, https://devblogs.microsoft.com/cppblog/cpp-modules-in-visual-studio-2017/, abgerufen am 13. Juli 2020

[17] C++20 Features and Fixes in VS2019 16.1 through 16.6, https://devblogs.microsoft.com/cppblog/c20-features-and-fixes-in-vs-2019-16-1-through-16-6/?utm_source=vs_developer_news&utm_medium=referral, abgerufen am 13. Jul 2020


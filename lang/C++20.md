# C++20

[TOC]

## Modules

Module stellen eine Alternative zu Header-Dateien dar. Siehe auch das Modulkonzept in anderen Sprachen, z.B. Python. Die Vorteile liegen auf der Hand:

- Die Trennung von Header- und Quelldateien aufzulösen
- Verzicht auf Präprozessor-Anweisungen
- Abhängigkeiten von include-Anweisungen zu eliminieren
- schnellere Kompilierzeiten

```C++
import std; // import declaration

int main() 
{
	std::cout << "Hello World" << std::endl; 
} 
```

## Coroutines

Coroutinen unterstützen die asynchrone Programmierung. Es handelt sich um Funktionen, die ihre Ausführung anhalten und wieder aufnehmen können. Dabei behalten sie ihren Zustand. 

C++20 liefert keine konkreten Coroutinen, sondern ein Framework für das Schreiben von Coroutinen. 

```C++
Acceptor accept{443};

while (true)
{
    Socket so = co_await accept.accept();
    auto req = co_await so.read();
    auto resp = handleRequest(req);
    co_await so.write(resp);
}
```

Ein Aufruf wie *auto req = co_await so.read* wartet nicht, bis die Daten verfügbar sind. Stattdessen kommt er sofort zurück und setzt seine Arbeit dann fort, wenn Daten tatsächlich verfügbar sind. 

```c++
Generator<int> getNext(int start = 0, int step = 1)
{
    auto value = start;
    for (int i = 0;; ++i)
    {
        co_yield value;         
        value += step;
    }
}

int main() 
{    
    std::cout << std::endl;
  
    std::cout << "getNext():";
    auto gen = getNext();
    for (int i = 0; i <= 10; ++i) 
    {
        gen.next();             
        std::cout << " " << gen.getValue();                  
    }
   
   std::cout << std::endl;
}
```

Im obigen Beispiel ist *getNext* eine Coroutine. *getNext* besitzt eine Endlosschleife, die den Wert nach *co_yield* zurückgibt. Ein Aufruf *next()* weckt die Coroutine, mit *getValue()* kann danach der Wert abgeholt werden. 

## Concepts

Concepts sind eine Erweiterung der Templates und werden Bestandteil von C++20 sein. Zusätzlich wird eine vereinfachte Syntax eingeführt werden.  

Concepts sind Prädikate zur Compile-Zeit. Sie werden während der Übersetzung evaluiert und liefern einen Wahrheitswert. 

Damit ist es möglich, Anforderungen an die Templates als Teil des Interfaces zu formulieren. Dadurch sollten kryptische Fehlermeldungen des Compilers bei Instanziierung eines Templates mit fehlerhaftem Datentyp Vergangenheit sein. 

In den folgenden Beispielen wird das Concept *Integral* verwendet. 

```c++
template<typename T>
requires Integral<T>()
T ggt(T a, T b)
{
  if (b == 0)
  {
      return a; 
  }
  else
  {
  	return ggt(b, a % b);
  }
}
```

Der Template-Parameter T muß ein *Integral* sein. Man kann das Ganze noch abkürzen. 

```c++
template<Integral T>
T ggt(T a, T b)
{
  if (b == 0)
  { 
      return a; 
  }
  else
  {
  	return ggt(b, a % b);
  }
}
```

Und man kann es tatsächlich nochmals abkürzen. 

```c++
Integral auto ggt(Integral& a, Integral& b)
{
	if (b == 0)
  	{ 
    	return a; 
  	}	
  	else
  	{
  		return ggt(b, a % b);
  	}
}
```

Die Definition des Concept Integral sieht folgendermaßen aus. 

```c++
template<typename T> concept bool Integral()
{
	return std::is_integral<T>::value; 
}
```

## Ranges

Die Bibliothek erlaubt es, wie schon von anderen Sprachen bekannt (z.B. Python), die Algorithmen der Standard Template Library direkt auf Containern auszuführen. Algorithmen lassen sich mit dem Pipe-Symbol ("|") verknüpfen und die Auswertung kann erst bei Nachfrage erfolgen ("lazy evaluation").  

```c++
#include <vector>
#include <ranges>
#include <iostream>
 
int main()
{
	std::vector<int> ints{0, 1, 2, 3, 4, 5};
  	auto even = [](int i){ return 0 == i % 2; };
  	auto square = [](int i) { return i * i; };
 
  	for (int i : ints | std::view::filter(even) |                                     
        std::view::transform(square)) 
   {
   	std::cout << i << ' ';             // 0 4 16
  	}
}
```

Innerhalb der for-Anweisung sieht man die Funktionskomposition mit dem Pipe-Symbol, die man von links nach rechts lesen muss. Wende für jedes Element von *ints* den Filter *even* an und bilde die verbleibenden Argumente auf ihr Quadrat ab. 

## Vergleichsoperator <=> und

Der Vergleichsoperator <=> bestimmt für zwei Werte A und B, ob A<B, A=B oder A>B ist. Der Compiler kann den Drei-Wege-Vergleichsoperator automatisch erzeugen, indem er mit dem Schlüsselwort *default* darauf hingewiesen wird. 

```c++
// C++20 Spaceship Operator
#include <iostream>
#include <compare>

struct MyInt
{
   int value; 
   MyInt(int v) {value=v;}
   auto operator<=>(const MyInt&) const = default; 
}; 

int main()
{
   MyInt a(4);
   MyInt b(4); 
   
   static_assert(a == b);
   
   return 0;
}
```

## constexpr virtuelle Funktionen

*constexpr* Funktionen durften bisher nicht virtuell sein. Diese Einschränkung fällt mit C++20 weg. 

## Designated Initializers  

Mit diesem Feature können (unter anderem) Teile eines *struct* definiert werden. 

```C++
// C++20 Designated Initializer
#include <iostream>

int main()
{
   struct Point
   {
      int x; 
      int y; 
   };
   
   // C++11 initialisation
   Point point {1, 1};  
   
   std::cout << "Point " << point.x << " " << point.y << std::endl;
   
   // C++20 Designated Initializer
   Point point2 {.x = 2, .y = 2};
   
   std::cout << "Point " << point2.x << " " << point2.y << std::endl;
   
   return 0;
}
```

## String-Literale als Template-Parameter

Man konnte bisher einen String nicht als Template-Parameter einsetzen (außer typisierten Templates). Mit C++20 ist dies nun möglich. 

```c++
template<std::basic_fixed_string T> 
class Foo 
{
	static constexpr char const* Name = T;
public:
	void hello() const;
};

int main() 
{
    Foo<"Hello!"> foo;
    foo.hello();
}

// Hello!
```

## Lambda improvements

Die **implizite Bindung von this** bei Verwendung von [=] ist Geschichte. 

```c++
struct Lambda 
{
   auto foo() 
   {
// warning: implicit capture of 'this' via '[=]' is deprecated in C++20 [-Wdeprecated]
       return [=] { std::cout << s << std::endl; };
// warning: implicit capture of 'this' via '[=]' is deprecated in C++20 [-Wdeprecated]
   }

   std::string s;
};

struct LambdaCpp20 
{
   auto foo() 
   {
      // OK
      return [=, this] { std::cout << s << std::endl; };
   }

   std::string s;
};
```

**Template-Lambdas** 

Manchmal ist es notwendig, eine Lambda-Funktion zu definieren, die nur für bestimmte Datentypen verwendet werden kann. C++20 unterstützt dafür jetzt *Template-Lambdas*. 

```c++
auto foo = []<typename T>(std::vector<T> const& vec) { 
   // do vector specific stuff 
};
```

## Attribute

| Attribut     | Beschreibung                                                 |
| ------------ | ------------------------------------------------------------ |
| [[likely]]   | Codepfad wird mit höherer Wahrscheinlichkeit ausgeführt      |
| [[unlikely]] | Codepfad wird mit höherer Wahrscheinlichkeit nicht ausgeführt |

## consteval und consinit

Mit *consteval* erzeugt man eine sogenannte Immediate-Funktion. Jeder Aufruf erzeugt einen konstanten Ausdruck, der zur Compilezeit ausgewertet werden kann. 

*constinit* gibt die Garantie, dass eine Variable mit statischer Speicherdauer zur Compilezeit initialisiert wird. 

## std::source_location

Die Klasse std::source_location gibt den Dateinamen, die Zeilen- und die Spaltennummer und den Funktionsnamen zurück. Damit kann man auf die allseits beliebten Präprozessor-Makros LINE und FILE verzichten. 

```c++
#include <source_location>

// ....
```




[1] <https://herbsutter.com/2017/07/15/trip-report-summer-iso-c-standards-meeting-toronto/>

[2] [https://www.heise.de/developer/meldung/Programmiersprachen-Erste-Plaene-fuer-C-20-veroeffentlicht-3772568.htm](https://www.heise.de/developer/meldung/Programmiersprachen-Erste-Plaene-fuer-C-20-veroeffentlicht-3772568.html), abgerufen am 19. November 2018

[3] <https://www.heise.de/developer/meldung/C-20-bekommt-Ranges-und-Erweiterungen-bei-Concepts-4224738.html>, abgerufen am 19. November 2018

[4] <https://herbsutter.com/2018/11/13/trip-report-fall-iso-c-standards-meeting-san-diego/>, abgerufen am 19. November 2018  

[5] https://www.heise.de/developer/meldung/Programmiersprache-Der-Entwurf-von-C-20-ist-abgeschlossen-4317206.html, abgerufen am 25. Februar 2019

[6] Bartek's coding blog, https://www.bfilipek.com/, abgerufen am 12. März 2019

[7] Blog Modernes C++, https://www.heise.de/developer/artikel/Ein-neuer-Thread-mit-C-20-std-jthread-4197595.html, abgerufen am 22. Mai 2019

[8] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Die-vier-grossen-Neuerungen-4568956.html, abgerufen am 05. November 2019

[9] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Ueberblick-zur-Kernsprache-4574153.html, abgerufen am 05. November 2019 

[10] Simplify Your Code With Rocket Science: C++20’s Spaceship Operator, https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/, abgerufen am 07. November 2019

[11] Lambdas: From C++11 to C++20, https://www.bfilipek.com/2019/02/lambdas-story-part1.html, abgerufen am 08. November 2019



  
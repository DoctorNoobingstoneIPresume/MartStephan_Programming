# C++20

[TOC]

Table of Contents
=================

* [C\+\+20](#c20)
* [Table of Contents](#table-of-contents)
  * [Modules](#modules)
  * [Coroutines](#coroutines)
  * [Concepts](#concepts)
  * [Ranges](#ranges)
  * [Vergleichsoperator &lt;=&gt; und](#vergleichsoperator--und)
  * [Designated Initializers](#designated-initializers)
  * [String\-Literale als Template\-Parameter](#string-literale-als-template-parameter)
  * [constexpr virtuelle Funktionen](#constexpr-virtuelle-funktionen)
  * [Lambda improvements](#lambda-improvements)
  * [Attribute](#attribute)
  * [consteval und consinit](#consteval-und-consinit)
  * [std::source\_location](#stdsource_location)
  * [Concurrency](#concurrency)
  * [use of using enum](#use-of-using-enum)
  * [volatile](#volatile)
  * [Algorithmen](#algorithmen)
  * [Bibliothek](#bibliothek)
  * [Literatur](#literatur)

Created by [gh-md-toc](https://github.com/ekalinin/github-markdown-toc.go)https://github.com/ekalinin/github-markdown-toc.go)

## Modules

Module stellen eine Alternative zu Header-Dateien dar. Siehe auch das Modulkonzept in anderen Sprachen, z.B. Python. Die Vorteile liegen auf der Hand:

- Die Trennung von Header- und Quelldateien aufzulösen
- Verzicht auf Präprozessor-Anweisungen
- Abhängigkeiten von include-Anweisungen zu eliminieren
- schnellere Kompilierzeiten

Aktuell verwendet Clang die Endung .cppm für Modulnamen, während cl.exe das Suffix .ixx verwendet. Das folgende Beispiel erstelle ich mit Clang. Mit gcc hatte ich bisher keinen Erfolg mit Modulen. Zuerst die Modul-Datei math.cppm.

```c++
// math.cppm

// this is our module declaration
export module math;

// now implement math functions 

// greatest common divisor
export int gcd(int first, int second)
{
   // using the Euclidean algorithm
   return second == 0 ? first : gcd(second, first % second);
} 

// least common multiple
export int lcm(int first, int second)
{
   int div = gcd(first, second); 
   return div ? (first * (second / div)) : 0;
}
```

Und noch unsere main.cpp.

```C++
// main.cpp
#include "stdio.h"

// Our first C++20 module - of course a math module
import math;

int main()
{   
   // call greatest common divisor from math module
   int res = gcd(2000, 20);
   printf("gcd %d\n", res);
   
   // call least common multiple from math module
   res = lcm(10, 100);
   printf("lcm %d", res);
}
```

Jetzt noch schnell kompilieren, um zu beweisen, dass es auch funktioniert. Ich benutze den Clang 10.0.0 Compiler dafür. 

```pseudocode
>>> clang++.exe -v
>>> clang version 10.0.0
>>> Target: x86_64-pc-windows-msvc
>>> Thread model: posix
>>> InstalledDir: d:\Program Files\LLVM\bin
```

Es geht los. 

```pseudocode
/// Erzeuge aus der Moduledeklaration math.cppm ein vorcompiliertes Modul math.pcm.
>>> clang++.exe -std=c++20 --precompile math.cppm -o math.pcm 

/// Erzeuge eine Übersetzungseinheit math.o, die kein Modul darstellt.
>>> clang++.exe -std=c++20 -c math.pcm -o math.o

/// Erzeuge eine ausführbare Datei math oder math.exe. clang++ benötigt hier noch den Pfad zum Modul.
>>> clang++.exe -std=c++20 -fmodules-ts -fprebuilt-module-path=. math.o main.cpp -o math.exe

/// math.exe ist ausführbar - und die Algorithmen sind korrekt. 
>>> math.exe 
>>> gcd 20
>>> lcm 100
```

## Coroutines

Coroutinen unterstützen die asynchrone Programmierung. Es handelt sich um Funktionen, die ihre Ausführung anhalten und wieder aufnehmen können. Dabei behalten sie ihren Zustand. 

C++20 liefert keine konkreten Coroutinen, sondern ein Framework für das Schreiben von Coroutinen. 

```C++
Acceptor accept{443};

while (true)
{
    Socket so = co_await accept.accept();
    auto req = co_await so.read();
    auto resp = handleRequest(req);
    co_await so.write(resp);
}
```

Ein Aufruf wie *auto req = co_await so.read* wartet nicht, bis die Daten verfügbar sind. Stattdessen kommt er sofort zurück und setzt seine Arbeit dann fort, wenn Daten tatsächlich verfügbar sind. 

```c++
Generator<int> getNext(int start = 0, int step = 1)
{
    auto value = start;
    for (int i = 0;; ++i)
    {
        co_yield value;         
        value += step;
    }
}

int main() 
{    
    std::cout << std::endl;
  
    std::cout << "getNext():";
    auto gen = getNext();
    for (int i = 0; i <= 10; ++i) 
    {
        gen.next();             
        std::cout << " " << gen.getValue();                  
    }
   
   std::cout << std::endl;
}
```

Im obigen Beispiel ist *getNext* eine Coroutine. *getNext* besitzt eine Endlosschleife, die den Wert nach *co_yield* zurückgibt. Ein Aufruf *next()* weckt die Coroutine, mit *getValue()* kann danach der Wert abgeholt werden. 

## Concepts

*Concepts* sind eine Erweiterung der Templates und sind Bestandteil von C++20. Zusätzlich wird eine vereinfachte Syntax eingeführt.  

*Concepts* sind Prädikate zur Compile-Zeit. Sie werden während der Übersetzung evaluiert und liefern einen Wahrheitswert. 

Damit ist es möglich, Anforderungen an die Templates als Teil des Interfaces zu formulieren. Dadurch sollten kryptische Fehlermeldungen des Compilers bei Instanziierung eines Templates mit fehlerhaftem Datentyp Vergangenheit sein. 

Du kannst vordefinierte *Concepts* verwenden oder deine eigenen *Concepts* definieren.

In den folgenden Beispielen wird das Concept *Integral* verwendet. 

```c++
/// C++20: concepts
#include <iostream>
#include <concepts>

// concept using a Require Clause
template<typename T> requires std::integral<T>
T ggt(T a, T b)
{
  if (b == 0)
  {
      return a; 
  }
  else
  {
  	return ggt(b, a % b);
  }
}

int main()
{
   auto res = ggt(8, 12);
    
   std::cout << "ggt is " << res << "\n";
}

///> ggt is 4
```

Der Template-Parameter T muß ein *Integral* sein. Man kann das Ganze noch abkürzen. 

```c++
/// C++20: concepts
#include <iostream>
#include <concepts>

// concept using Contrained Template Parameters
template<std::integral T>
T ggt(T a, T b)
{
  if (b == 0)
  { 
      return a; 
  }
  else
  {
  	return ggt(b, a % b);
  }
}

int main()
{
   auto res = ggt(8, 12);
    
   std::cout << "ggt is " << res << "\n";
}

///> ggt is 4
```

Die Definition des *Concept* *Integral* sieht folgendermaßen aus. 

```c++
template<typename T> concept bool integral()
{
   return std::is_integral<T>::value; 
}
```

Damit kann ich auch meine eigenen *Concepts* definieren.

```c++
/// C++20: user-defined concepts
#include <iostream>
#include <concepts>
#include <type_traits>
#include <vector>

template<typename T> concept MyIntegral = std::is_integral<T>::value;

MyIntegral auto getIntegral(int val)
{
   return val;
}

template<MyIntegral T> T ggt(T a, T b)
{
   if (b == 0)
   { 
      return a; 
   }	
   else
   {
      return ggt(b, a % b);
   }
}

int main()
{
   auto res = ggt(8, 12);
    
   std::cout << "ggt is " << res << "\n";
    
   std::vector<int> vec{1, 2, 3, 4, 5};
   for (MyIntegral auto i: vec)
   {
      std::cout << i << " ";
   }
 
   std::cout << std::boolalpha << std::endl;
    
   MyIntegral auto b = true; 
   std::cout << b << std::endl;
}

///> ggt is 4
///> 1 2 3 4 5 
///> true
```

Es lohnt sich definitiv, sich damit zu beschäftigen und zu schauen, welche *Concepts* schon vordefiniert sind. Man will ja nicht *Concepts* definieren, die schon vordefiniert sind. Im folgenden eine (nicht zwingendermaßen vollständige) Übersicht der vordefinierten *Concepts*.

| Concept                                                      | Beschreibung                                     |
| ------------------------------------------------------------ | ------------------------------------------------ |
| three_way_comparable                                         | Unterstützt den Drei-Wege-Vergleichsoperator <=> |
| same_as, derived_from, convertible_to, common_reference_with, common_with, assignable_from, swappable |                                                  |
| integral, signed_integral, unsigned_integral, floating_point |                                                  |
| destructible, constructible_from, default_constructible, move_constructable, copy_constructable |                                                  |
| boolean, equality_comparable, totally_ordered                |                                                  |
| movable, copyable, semiregular, regular                      |                                                  |
| invocable, regular_invocable, predicate                      |                                                  |
| input_iterator, output_iterator, forward_iterator, bidirectional_iterator, random_access_iterator, contiguous_iterator |                                                  |
| permutable, mergeable, sortable                              |                                                  |
| uniform_random_bit_generator                                 |                                                  |

## Ranges

Die Bibliothek erlaubt es, wie schon von anderen Sprachen bekannt (z.B. Python), die Algorithmen der Standard Template Library direkt auf Containern auszuführen. Algorithmen lassen sich mit dem Pipe-Symbol ("|") verknüpfen und die Auswertung kann erst bei Nachfrage erfolgen ("lazy evaluation").  

```c++
#include <vector>
#include <ranges>
#include <iostream>
 
int main()
{
   std::vector<int> ints{0, 1, 2, 3, 4, 5};
   auto even = [](int i){ return 0 == i % 2; };
   auto square = [](int i) { return i * i; };
 
   for (int i : ints | std::view::filter(even) | std::view::transform(square)) 
   {
      std::cout << i << ' ';             // 0 4 16
   }
}
```

Innerhalb der for-Anweisung sieht man die Funktionskomposition mit dem Pipe-Symbol, die man von links nach rechts lesen muss. Wende für jedes Element von *ints* den Filter *even* an und bilde die verbleibenden Argumente auf ihr Quadrat ab. 

## Vergleichsoperator <=> und

Der Vergleichsoperator <=> bestimmt für zwei Werte A und B, ob A<B, A=B oder A>B ist. Der Compiler kann den Drei-Wege-Vergleichsoperator automatisch erzeugen, indem er mit dem Schlüsselwort *default* darauf hingewiesen wird. Dadurch bietet er alle sechs Vergleichsoperatoren: ==, !=, <, <=, >, >=. Details findet man auch auf [10].

Der Vergleichsoperator wird auch *Spaceship Operator* genannt.

```c++
// C++20 Spaceship Operator
#include <iostream>
#include <compare>

struct MyInt
{
   int value; 
   MyInt(int v) {value=v;}
   auto operator<=>(const MyInt&) const = default; 
}; 

int main()
{
   MyInt a(4);
   MyInt b(4); 
   
   if (a ==  b)
   {
      std::cout << "a equals b\n";
   }
   
   return 0;
}

///>>> a equals b
```

## Designated Initializers  

Mit diesem Feature können (unter anderem) Teile eines *struct* definiert werden. 

```C++
// C++20 Designated Initializer
#include <iostream>

int main()
{
   struct Point
   {
      int x; 
      int y; 
   };
   
   // C++11 initialisation
   Point point {1, 1};  
   
   std::cout << "Point " << point.x << " " << point.y << std::endl;
   
   // C++20 Designated Initializer
   Point point2 {.x = 2, .y = 2};
    
   std::cout << "Point " << point2.x << " " << point2.y << std::endl;
    
   // C++20 also possible - but compiler should place a warning - default initialization to 0
   Point point3 {.x =2};
   
   std::cout << "Point " << point3.x << " " << point3.y << std::endl;
   
   return 0;
}

///> Point 1 1
///> Point 2 2
///> Point 2 0
```

## String-Literale als Template-Parameter

Man konnte bisher einen String nicht als Template-Parameter einsetzen (außer typisierten Templates). Mit C++20 ist dies nun möglich. Es bietet sich an, den im Standard definierten *basic_fixed_string* zu nehmen, da dieser einen *constexpr*-Konstruktor besitzt. 

```c++
/// C++20: String-Literale als Template-Parameter
template<std::basic_fixed_string T> 
class Foo 
{
   static constexpr char const* Name = T;
   public:
      void hello() const;
};

int main() 
{
   Foo<"Hello!"> foo;
   foo.hello();
}

// Hello!
```

ACHTUNG: Bisher konnte ich es nicht zum Laufen bringen, da *basic_fixed_string* es wohl nicht in den C++20 Standard geschafft hat. Genaueres als Aufgabe für eine Recherche.

## constexpr virtuelle Funktionen

*constexpr* Funktionen durften bisher nicht virtuell sein. Diese Einschränkung fällt mit C++20 weg. 

## Lambda improvements

Die **implizite Bindung von this** bei Verwendung von [=] ist Geschichte. 

```c++
/// C++20: Lambda improvements
#include <iostream>

struct Lambda 
{
   auto foo() 
   {
      // warning: implicit capture of 'this' via '[=]' is deprecated in C++20 [-Wdeprecated]
      return [=] { std::cout << s << std::endl; };
      // warning: implicit capture of 'this' via '[=]' is deprecated in C++20 [-Wdeprecated]
   }

   std::string s;
};

struct LambdaCpp20 
{
   auto foo() 
   {
      // OK
      return [=, this] { std::cout << s << std::endl; };
   }

   std::string s;
};
```

**Template-Lambdas** 

Manchmal ist es notwendig, eine Lambda-Funktion zu definieren, die nur für bestimmte Datentypen verwendet werden kann. C++20 unterstützt dafür jetzt *Template-Lambdas*. 

```c++
/// C++20: Template Lambdas
#include <iostream>
#include <vector>

int main() 
{
   std::vector<int> my_vec = {1, 2, 3};
   
   auto foo = []<typename T>(std::vector<T> const& vec) 
    { 
        if (vec.size()>0)
        {
           return vec[0];
        }
        else
        {
           return 0;
        }
    };
    
    //int res = foo(42); /// does not compile - error: no match for call to '(main()::<lambda(const std::vector<T>&)>) (int)'
    int res = foo(my_vec);
    std::cout << "res " << res << std::endl;
}

///> res 1
```

Details zu Lambda-Verbesserungen von C++11 bis C++20 können in [11] nachgelesen werden.

## Attribute

| Attribut     | Beschreibung                                                 |
| ------------ | ------------------------------------------------------------ |
| [[likely]]   | Codepfad wird mit höherer Wahrscheinlichkeit ausgeführt      |
| [[unlikely]] | Codepfad wird mit höherer Wahrscheinlichkeit nicht ausgeführt |

```c++
/// C++20: Attributes
#include <iostream>
#include <vector>
#include <cmath>

int main() 
{
   double sum = 0.0;
   std::vector<int> numbers = {2, 3, 4, 5};
    
   for (size_t i=0; i < numbers.size(); ++i)
   {
      if (numbers[i] < 0) [[unlikely]] 
      {
         sum -= std::sqrt(-numbers[i]);
      }
      else 
      {
         sum += std::sqrt(numbers[i]);
      }
   }
    
    std::cout << "sum " << sum << std::endl; 
}

///> sum 7.38233
```

## consteval und consinit

Mit *consteval* erzeugt man eine sogenannte Immediate-Funktion. Jeder Aufruf erzeugt einen konstanten Ausdruck, der zur Compilezeit ausgewertet werden kann. Ist also implizit eine *constexpr*-Funktion.

```c++
/// C++20: consteval
#include <iostream>

consteval int square(int n) 
{
   return n*n;
}

int main() 
{  
   constexpr int res = square(42); 
    
   std::cout << "res " << res << std::endl;
}

///> res 1764
```

*constinit* gibt die Garantie, dass eine Variable mit statischer Speicherdauer zur Compilezeit initialisiert wird. 

## std::source_location

Die Klasse *std::source_location* gibt den Dateinamen, die Zeilen- und die Spaltennummer und den Funktionsnamen zurück. Damit kann man auf die allseits beliebten Präprozessor-Makros LINE und FILE verzichten. 

```c++
/// C++20: std::source_location
#include <iostream>
#include <string_view>
#include <source_location>
 
void log(std::string_view message, const std::source_location& location = std::source_location::current())
{
    std::cout << "info:"
              << location.file_name() << ":"
              << location.line() << " "
              << message << '\n';
}
 
int main()
{
    log("Hello world!");
}

///> info:prog.cc:16 Hello world!
```

## Concurrency

**std::atomic_ref**

Das Klassen-Template *std::atomic_ref* bietet atomare Operationen auf das referenzierte, nicht atomare Objekt an. Gleichzeitiges Lesen und Schreiben auf ein Objekt ist damit kein Data Race mehr.

```c++
/// C++20: format
#include <iostream>
#include <atomic>

struct Counters 
{ 
   int a; 
   int b;
} counter; // user-defined trivially-copyable type

int main()
{
   std::cout << "Hallo " << std::endl;
    
   // specialization for the user-defined type
   std::atomic_ref<Counters> cnt(counter); 
}
```

**Atomare Shared Pointer und Weak Pointer**

Shared Pointer und Weak Pointer gibt es jetzt auch atomar. 

**Atomare Gleitkommazahlen**

Seit C++11 gibt es schon atomare Ganzzahlen. Mit C++20 bekommen wir atomare Gleitkommazahlen. 

**Semaphoren, Latches und Barriers** 

Mit C++20 bekommen wir eine eingebaute Semaphore-Implementierung. 

Mit *Latches* und *Barriers* werden einfache Synchronisationsmechanismen eingeführt. Sie erlauben es, Threads zu blockieren, bis ein Zähler den Wert 0 besitzt. 

Ein *std::latch* kann nur einmal verwendet werden. Ein *std::barrier* lässt sich mehrmals verwenden.

```c++

```

**Joining Thread**

Ein Joining Thread (*std::jthread*) 'joint' automatisch und er kann auch unterbrochen werden. Mit *std::thread* aus C++11 war das bisher nicht möglich. 

```c++

```

## use of using enum

In C++20 ist es jetzt möglich, die using-Anweisung zu nutzen, um den Namen des Enums im Bereich bekannt zu machen. 

```c++
/**
 * C++20 using enum example
 */
#include <stdio.h>
#include <iostream>
#include <type_traits>

// scoped enum specifying underlying type 
enum class Color: std::uint8_t 
{
   red = 0x1,
   blue = 0x2, 
   green = 0x3,
};

std::string_view what_color(Color color)
{
   switch (color)
   {
      using enum Color;   /// this should work but unfortunately it doesn't yet compile (tested with gcc 10.1.0, clang 10.0.0, C++2a)
      case Color::red: return "red";
      case Color::blue: return "blue";
      case Color::green: return "green";
   }
}

int main()
{  
   // before c++17 I had to use a static_cast
   Color my_favourite_color{static_cast<Color>(0x3)};
   
   // C++17 simplifies it
   Color my_new_favourite_color{0x2};
   
   std::cout << "my favourite color is " << +static_cast<std::underlying_type_t<Color> >(my_favourite_color) << std::endl;
   
   std::cout << "my new favourite color is " << +static_cast<std::underlying_type_t<Color> >(my_new_favourite_color) << std::endl;
      
   return 0;
}

// unfortunately I couldn't yet compile it using gcc 10.1.0, clang 10.0.0, C++2a
```

## volatile

C++20 führt eine Neudefinition von *volatile* ein.

## Algorithmen

**std::find, std::find_if, std::find_if_not**

Da habe ich schon lange darauf gewartet. Endlich gibt es Suchfunktionen für die Containerklassen. Das vereinfacht das Leben doch enorm. Zum Beispiel wenn ich mir die Frage nach dem Sinn des Lebens stelle. 

```c++
// C++20 find example
#include <iostream>
#include <vector>

int main()
{
   std::cout << "Hello, Wandbox!" << std::endl;
    
   std::vector<int> myvector {1, 10, 1000, 4, 42, 399};
    
   // Find die Antwort auf den Sinn des Lebens in einer Zeile Code!
   auto result = std::find(myvector.begin(), myvector.end(), 42);
   
   if (result!=std::end(myvector))
   {
      std::cout << "Found the answer\n";
   }
   else 
   {
      std::cout << "Didn't find the answer\n"; 
   }
   std::cout << std::endl;
}

//Found the answer
```

## Bibliothek 

**chrono**

Die chrono-Bibliothek (die schon seit C++11/C++14 exisitiert) wurde um einen Kalender und um Zeitzonen erweitert. Damit ist es nun möglich:

- ein Datum in verschiedenen Formaten zu repräsentieren
- den letzten Tag eines Monats zu bestimmen
- die Anzahl der Tage zwischen zwei Daten zu bestimmen
- die Ausgabe der aktuellen Zeit in verschiedenen Zeitzonen zu bestimmen
- es gibt zwei neue Literale: *d* für einen Tag und *y* für ein Jahr
- der "/" Operator kann zum Umgang mit Zeitpunkten verwendet werden
- Zeitzonen: Zeitpunkte lassen sich in verschiedenen Zeitzonen darstellen

```c++
/// C++20: chrono
#include <iostream>
#include <chrono>
 
int main()
{
    //auto d1 = 2020y/dec/24;
    //auto d2 = 24d/dec/2020;
    //auto d3 = dec/24/2020; 
    
    auto now = std::chrono::system_clock::now();
    
    std::cout << "jetzt ist " << now << std::endl;
}
```

Für Beispiele siehe auch [18].

**std::span**

*std::span* steht für ein Objekt, das sich auf eine zusammenhängende Sequenz von Objekten bezieht. Der zusammenhängende Bereich kann ein Array, ein Zeiger oder auch ein *std::vector* sein.

*std::span* bestimmt automatisch die Länge eines C-Arrays, eines *std::vector* oder eines *std::array*. 

```c++
// C++20 std::span
#include <iostream>
#include <span>

template<typename T>
void copyN(T* src, T* dest, int n)
{
   for (int i=0; i<n; i++)
   {
      dest[i] = src[i];
   }
}

void copySpan(std::span<int> src, std::span<int> dest)
{
   std::cout << "src size " << src.size() << "\n";
   std::cout << "dest size " << dest.size() << "\n";
   
   if (dest.size() < src.size())
   {
      return;
   }
   
   if (src.size() >= 2)
   {
      std::cout << "src[0] " << src[0] << "\n";
   }
   
   for (int i=0; i<src.size(); i++)
   {
      dest[i] = src[i];
   }
   
   return;
}

int main()
{
   int arr1[] = {1, 2, 3};
   int arr2[] = {3, 4, 5};
  
   copyN(arr1, arr2, 3);
   std::cout << "copyN ";
   for (int i=0; i<3; i++)
   {
      std::cout << " " << arr2[i];
   }
   std::cout << std::endl;
   
   // Usage of std::span. No need to add the array length.
   // This is much more convenient and reduces the risk of a size mismatch.
   copySpan(std::span{arr1}, std::span{arr2});
   
   return 0;
}

///> copyN  1 2 3
///> std::span(src) size 3
///> std::span(dest) size 3
///> src[0] 1
```

**constexpr-Container**

*std::string* und *std::vector* erhalten jetzt Überladungen mit *constexpr*. Dadurch können Funktionen der Container-Klassen potenziell zur Compilezeit verwendet werden. 

Details können in [19] nachgelesen werden. 

**std::format**

Die *std::format* Bibliothek bietet jetzt eine Alternative zur printf-Funktionalität. 

```c++
/// C++20: format
#include <iostream>
#include <format>
 
int main()
{
   std::string message = std::format("The answer is {}.", 42);
}
```


## Literatur

[1] <https://herbsutter.com/2017/07/15/trip-report-summer-iso-c-standards-meeting-toronto/>

[2] [https://www.heise.de/developer/meldung/Programmiersprachen-Erste-Plaene-fuer-C-20-veroeffentlicht-3772568.htm](https://www.heise.de/developer/meldung/Programmiersprachen-Erste-Plaene-fuer-C-20-veroeffentlicht-3772568.html), abgerufen am 19. November 2018

[3] <https://www.heise.de/developer/meldung/C-20-bekommt-Ranges-und-Erweiterungen-bei-Concepts-4224738.html>, abgerufen am 19. November 2018

[4] <https://herbsutter.com/2018/11/13/trip-report-fall-iso-c-standards-meeting-san-diego/>, abgerufen am 19. November 2018  

[5] https://www.heise.de/developer/meldung/Programmiersprache-Der-Entwurf-von-C-20-ist-abgeschlossen-4317206.html, abgerufen am 25. Februar 2019

[6] Bartek's coding blog, https://www.bfilipek.com/, abgerufen am 12. März 2019

[7] Blog Modernes C++, https://www.heise.de/developer/artikel/Ein-neuer-Thread-mit-C-20-std-jthread-4197595.html, abgerufen am 22. Mai 2019

[8] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Die-vier-grossen-Neuerungen-4568956.html, abgerufen am 05. November 2019

[9] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Ueberblick-zur-Kernsprache-4574153.html, abgerufen am 05. November 2019 

[10] Simplify Your Code With Rocket Science: C++20’s Spaceship Operator, https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/, abgerufen am 18. Dezember 2020

[11] Lambdas: From C++11 to C++20, https://www.bfilipek.com/2019/02/lambdas-story-part1.html, abgerufen am 08. November 2019

[12] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Ueberblick-zur-Bibliothek-4582224.html, abgerufen am 18. November 2019

[13] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Ueberblick-zur-Concurrency-4585408.html, abgerufen am 14. Dezember 2019

[14] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Concepts-die-Details-4599997.html, abgerufen am 16. Januar 2020

[15] C++20 is here!, YouTube, https://www.youtube.com/watch?v=AvPiGstxV_g, abgerufen am 19. Februar 2020

[16] Using C++ Modules in Visual Studio 2017, https://devblogs.microsoft.com/cppblog/cpp-modules-in-visual-studio-2017/, abgerufen am 13. Juli 2020

[17] C++20 Features and Fixes in VS2019 16.1 through 16.6, https://devblogs.microsoft.com/cppblog/c20-features-and-fixes-in-vs-2019-16-1-through-16-6/?utm_source=vs_developer_news&utm_medium=referral, abgerufen am 13. Jul 2020

[18] Howard Hinnant, A date and time library based on the C++11/14/17 <chrono> header, https://github.com/HowardHinnant/date, abgerufen am 21. Dezember 2020

[19] Standard containers and constexpr, http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0784r1.html, abgerufen am 21. Dezember 2020